<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Network Routing Visualization</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Specific styles for the D3 visualization */
        .visualization-container {
            margin: 2rem auto;
            width: 100%;
            max-width: 1000px;
            height: 500px;
            border-radius: var(--border-radius);
            background-color: #f8f9fa;
            box-shadow: var(--card-shadow);
            position: relative;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin: 1rem 0 2rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .control-button {
            padding: 8px 16px;
            background-color: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-button:hover {
            border-color: #aaa;
            transform: translateY(-2px);
        }
        
        .control-button.meshtastic {
            border-color: var(--meshtastic-color);
        }
        
        .control-button.meshtastic.active {
            background-color: var(--meshtastic-color);
            color: white;
        }
        
        .control-button.meshcore {
            border-color: var(--meshcore-color);
        }
        
        .control-button.meshcore.active {
            background-color: var(--meshcore-color);
            color: white;
        }
        
        .control-button.action {
            border-color: var(--accent-color);
        }
        
        .control-button.action.active {
            background-color: var(--accent-color);
            color: white;
        }
        
        .phase-caption {
            text-align: center;
            padding: 1rem;
            margin-top: 1rem;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: var(--border-radius);
            max-width: 600px;
            margin: 0 auto;
            font-weight: 500;
            border-left: 4px solid var(--accent-color);
        }
        
        .network-node {
            cursor: pointer;
        }
        
        .node-label {
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        
        .network-link {
            stroke-width: 2;
            stroke-opacity: 0.6;
        }
        
        .packet {
            fill-opacity: 0.8;
        }
        
        .packet-meshtastic {
            fill: var(--meshtastic-color);
        }
        
        .packet-meshcore {
            fill: var(--meshcore-color);
        }
        
        .packet-discovery {
            fill: #fd7e14;
        }
        
        .packet-dropped {
            fill: #dc3545;
        }
        
        .packet-ack {
            fill: #9c27b0;  /* Purple color for ACK packets */
            stroke: #fff;
            stroke-width: 2;
        }
        
        /* Expanding ring styles */
        .packet-ring {
            fill: none;
            stroke-width: 2;
            pointer-events: none;
        }
        
        .packet-ring.meshtastic-ring {
            stroke: var(--meshtastic-color);
        }
        
        .packet-ring.meshcore-ring {
            stroke: var(--meshcore-color);
        }
        
        .packet-ring.discovery-ring {
            stroke: #fd7e14;
        }
        
        .packet-ring.dropped-ring {
            stroke: #dc3545;
        }
        
        .packet-ring.ack-ring {
            stroke: #9c27b0;  /* Purple color for ACK rings */
            stroke-dasharray: 3,3;  /* Dashed stroke for ACK rings */
        }
        
        /* Flood wave animation */
        .flood-wave {
            fill: none;
            stroke-width: 3;
            pointer-events: none;
        }
        
        .flood-wave.meshtastic-wave {
            stroke: var(--meshtastic-color);
        }
        
        .flood-wave.meshcore-wave {
            stroke: var(--meshcore-color);
        }
        
        .node-range {
            fill-opacity: 0.1;
            stroke-opacity: 0.3;
            stroke-width: 1;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }
        
        .meshtastic-range {
            fill: var(--meshtastic-color);
            stroke: var(--meshtastic-color);
        }
        
        .meshcore-range {
            fill: var(--meshcore-color);
            stroke: var(--meshcore-color);
        }
        
        .tooltip {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            pointer-events: none;
            font-size: 14px;
            z-index: 100;
            transition: opacity 0.3s;
        }
        
        .compare-container {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .compare-item {
            flex: 1 1 calc(50% - 1rem);
            min-width: 280px;
            background-color: #fff;
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            padding: 1.5rem;
        }
        
        .compare-item h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
            text-align: center;
        }
        
        .compare-meshtastic h3 {
            border-color: var(--meshtastic-color);
            color: var(--meshtastic-color);
        }
        
        .compare-meshcore h3 {
            border-color: var(--meshcore-color);
            color: var(--meshcore-color);
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 1rem 0;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        
        /* Network Topology Selector Styles */
        .network-topology-selector {
            margin: 1.5rem 0;
            text-align: center;
            background-color: #fff;
            padding: 1rem;
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
        }
        
        .network-topology-selector h4 {
            margin: 0 0 0.5rem 0;
            color: var(--header-bg-color);
        }
        
        .topology-buttons {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        .topology-button {
            padding: 0.5rem 1rem;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .topology-button:hover {
            background-color: #e9ecef;
            transform: translateY(-2px);
        }
        
        .topology-button.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        /* Metrics Display Styles */
        .performance-metrics {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .metric-card {
            flex: 1;
            min-width: 150px;
            background-color: #fff;
            padding: 0.75rem;
            border-radius: var(--border-radius);
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0.5rem 0;
        }
        
        .metric-label {
            font-size: 0.85rem;
            color: #666;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Mesh Network Routing Visualization</h1>
            <p class="subtitle">Interactive Comparison of Routing Approaches</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul>
                <li><a href="index.html">Overview</a></li>
                <li><a href="#routing" class="active">Routing</a></li>
                <li><a href="technical.html">Technical Details</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="routing">
            <h2>Mesh Network Routing Visualization</h2>
            <p>This interactive visualization demonstrates the different routing approaches used by Meshtastic and MeshCore. Use the controls below to explore how packets are routed through the network.</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--meshtastic-color);"></div>
                    <span>Meshtastic Radio Wave</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--meshcore-color);"></div>
                    <span>MeshCore Radio Wave</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #fd7e14;"></div>
                    <span>Discovery Wave</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #dc3545;"></div>
                    <span>Dropped Signal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #9c27b0;"></div>
                    <span>Route ACK Signal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: rgba(76, 175, 80, 0.1); border: 1px dashed #4caf50;"></div>
                    <span>Node Transmission Range</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #dc3545;"></div>
                    <span>Red Flash: Duplicate Message Discarded</span>
                </div>
            </div>
            
            <div class="controls">
                <button id="btn-meshtastic" class="control-button meshtastic active">
                    <i class="fas fa-broadcast-tower"></i> Meshtastic Flooding
                </button>
                <button id="btn-meshcore-phase1" class="control-button meshcore">
                    <i class="fas fa-search"></i> MeshCore Path Discovery
                </button>
                <button id="btn-meshcore-phase2" class="control-button meshcore">
                    <i class="fas fa-route"></i> MeshCore Direct Routing
                </button>
                <button id="btn-compare" class="control-button action">
                    <i class="fas fa-balance-scale"></i> Compare Side-by-Side
                </button>
                <button id="btn-reset" class="control-button">
                    <i class="fas fa-redo"></i> Reset
                </button>
            </div>
            
            <div class="network-topology-selector">
                <h4>Network Topology:</h4>
                <div class="topology-buttons">
                    <button id="topology-random" class="topology-button active">
                        <i class="fas fa-random"></i> Random
                    </button>
                    <button id="topology-dense" class="topology-button">
                        <i class="fas fa-th"></i> Dense
                    </button>
                    <button id="topology-sparse" class="topology-button">
                        <i class="fas fa-grip-vertical"></i> Sparse
                    </button>
                    <button id="topology-linear" class="topology-button">
                        <i class="fas fa-ellipsis-h"></i> Linear
                    </button>
                    <button id="topology-star" class="topology-button">
                        <i class="fas fa-asterisk"></i> Star
                    </button>
                </div>
            </div>
            
            <div class="visualization-container" id="network-visualization">
                <!-- D3.js will render the visualization here -->
            </div>
            
            <div class="phase-caption" id="phase-caption">
                Meshtastic Flooding: Radio signals propagate through all nodes within range, which rebroadcast once per message to maximize delivery probability.
            </div>
            
            <div class="performance-metrics">
                <div class="metric-card">
                    <div class="metric-label">Total Packets Sent</div>
                    <div class="metric-value" id="metric-packets">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Network Efficiency</div>
                    <div class="metric-value" id="metric-efficiency">0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Delivery Time</div>
                    <div class="metric-value" id="metric-time">0ms</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Hops Required</div>
                    <div class="metric-value" id="metric-hops">0</div>
                </div>
            </div>
        </section>
        
        <section id="routing-comparison">
            <h2>Routing Methods Compared</h2>
            
            <div class="compare-container">
                <div class="compare-item compare-meshtastic">
                    <h3>Meshtastic Flooding Approach</h3>
                    <ul>
                        <li><strong>High redundancy:</strong> Messages are sent to all nodes within range, which rebroadcast to their neighbors</li>
                        <li><strong>Simple implementation:</strong> No complex routing tables or path discovery needed</li>
                        <li><strong>Higher delivery probability:</strong> Multiple paths increase chances of message delivery</li>
                        <li><strong>Bandwidth intensive:</strong> Network congestion increases with the number of nodes</li>
                        <li><strong>No path optimization:</strong> Uses the same bandwidth regardless of optimal paths</li>
                    </ul>
                </div>
                
                <div class="compare-item compare-meshcore">
                    <h3>MeshCore Selective Routing</h3>
                    <ul>
                        <li><strong>Path discovery phase:</strong> Initial flooding to find optimal route to destination</li>
                        <li><strong>Route establishment:</strong> Creates a persistent path between nodes</li>
                        <li><strong>Bandwidth efficiency:</strong> After path discovery, only nodes on the route forward packets</li>
                        <li><strong>Selective forwarding:</strong> Nodes not on the established route drop packets</li>
                        <li><strong>Adaptable routing:</strong> Routes can be re-established if network topology changes</li>
                    </ul>
                </div>
            </div>
            
            <div class="technical-section">
                <h3>Network Performance Considerations</h3>
                <p>The choice between flooding and selective routing depends on several factors:</p>
                <ul>
                    <li><strong>Network density:</strong> Dense networks benefit more from selective routing to reduce congestion</li>
                    <li><strong>Node reliability:</strong> Unreliable or mobile nodes may benefit from flooding's redundancy</li>
                    <li><strong>Message priority:</strong> MeshCore can prioritize critical messages while Meshtastic treats all messages equally</li>
                    <li><strong>Power consumption:</strong> Selective routing typically requires less overall transmission, saving power across the network</li>
                </ul>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2023 Mesh Networking Comparison. This is for informational purposes only.</p>
            <div class="footer-links">
                <a href="index.html">Overview</a>
                <a href="routing.html">Routing</a>
                <a href="technical.html">Technical Details</a>
            </div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // D3.js visualization code
            const width = document.getElementById('network-visualization').clientWidth;
            const height = document.getElementById('network-visualization').clientHeight;
            
            // Create SVG container
            const svg = d3.select('#network-visualization')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Create a group for the network
            const networkGroup = svg.append('g')
                .attr('class', 'network-group');
            
            // Add tooltip for nodes
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            // Performance metrics tracking variables
            let metrics = {
                packetsSent: 0,
                efficiency: 0,
                deliveryTime: 0,
                hopsRequired: 0
            };
            
            // Topology configurations
            const topologies = {
                random: {
                    name: "Random",
                    description: "Nodes are randomly distributed with varied connectivity",
                    generate: generateRandomTopology
                },
                dense: {
                    name: "Dense",
                    description: "Highly connected network with many redundant paths",
                    generate: generateDenseTopology
                },
                sparse: {
                    name: "Sparse",
                    description: "Limited connectivity with few redundant paths",
                    generate: generateSparseTopology
                },
                linear: {
                    name: "Linear",
                    description: "Nodes form a chain with limited alternative routes",
                    generate: generateLinearTopology
                },
                star: {
                    name: "Star",
                    description: "Central node connects to all others with minimal peripheral connections",
                    generate: generateStarTopology
                }
            };
            
            // Current topology
            let currentTopology = "random";
            
            // Generate network based on selected topology
            let nodes = [];
            let links = [];
            generateNetwork(currentTopology);
            
            // Event listeners for topology buttons
            document.querySelectorAll('.topology-button').forEach(button => {
                button.addEventListener('click', function() {
                    const topologyType = this.id.split('-')[1]; // Extract topology type from button ID
                    
                    // Update active button
                    document.querySelectorAll('.topology-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Generate new network with selected topology
                    currentTopology = topologyType;
                    generateNetwork(topologyType);
                    
                    // Reset any active simulation
                    resetVisualization();
                    
                    // Update caption
                    document.getElementById('phase-caption').innerText = 
                        `Network Topology: ${topologies[topologyType].name} - ${topologies[topologyType].description}`;
                });
            });
            
            // Add event listeners for control buttons
            document.getElementById('btn-meshtastic').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run Meshtastic flooding simulation
                animateMeshtasticFlooding();
            });
            
            document.getElementById('btn-meshcore-phase1').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run MeshCore path discovery simulation
                animateMeshcoreDiscovery();
            });
            
            document.getElementById('btn-meshcore-phase2').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run MeshCore direct routing simulation
                animateMeshcoreDirectRouting();
            });
            
            document.getElementById('btn-compare').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run comparison view
                animateComparison();
            });
            
            document.getElementById('btn-reset').addEventListener('click', function() {
                // Reset visualization
                resetVisualization();
                
                // Reset active button state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById('btn-meshtastic').classList.add('active');
                
                // Reset metrics
                resetMetrics();
                
                // Reset caption
                document.getElementById('phase-caption').innerText = 
                    'Select a routing method to visualize different approaches to mesh networking.';
            });
            
            // Function to generate network based on topology
            function generateNetwork(topologyType) {
                // Clear existing network
                networkGroup.selectAll('*').remove();
                
                // Get topology generator function
                const topologyGenerator = topologies[topologyType].generate;
                
                // Generate nodes and links
                const generatedNetwork = topologyGenerator();
                nodes = generatedNetwork.nodes;
                links = generatedNetwork.links;
                
                // Draw the network
                drawNetwork();
                
                // Reset metrics
                resetMetrics();
            }
            
            // Function to generate random topology
            function generateRandomTopology() {
                // Define nodes with random positions and ranges
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: getRandomRange(160, 240) }
                ];
                
                // Add regular nodes (original + more nodes for density)
                const regularNodeCount = 88; // Approximately 10x the original minus source/destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: getRandomRange(140, 220) 
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: getRandomRange(160, 240) });
                
                // Assign random positions with grid-like distribution for better coverage
                const gridSize = Math.ceil(Math.sqrt(nodes.length));
                const cellWidth = width / gridSize;
                const cellHeight = height / gridSize;
                
                nodes.forEach((node, index) => {
                    // Calculate grid position
                    const gridX = index % gridSize;
                    const gridY = Math.floor(index / gridSize);
                    
                    // Add some randomness within the cell
                    const jitterX = (Math.random() - 0.5) * cellWidth * 0.7;
                    const jitterY = (Math.random() - 0.5) * cellHeight * 0.7;
                    
                    node.x = (gridX + 0.5) * cellWidth + jitterX;
                    node.y = (gridY + 0.5) * cellHeight + jitterY;
                });
                
                // Override specific node positions for source and destination
                // Place A at left side
                nodes[0].x = width * 0.05;
                nodes[0].y = height * 0.5;
                
                // Place Z at right side
                nodes[nodes.length - 1].x = width * 0.95;
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Create links based on range
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate dense topology
            function generateDenseTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 300 }
                ];
                
                // Add regular nodes (original + more nodes for density)
                const regularNodeCount = 88; // Approximately 10x the original minus source/destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: 280 
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 300 });
                
                // Position in a grid pattern with clustering for density
                const gridSize = Math.ceil(Math.sqrt(nodes.length * 0.7)); // Use 70% of full grid for clustering
                const cellWidth = width / gridSize;
                const cellHeight = height / gridSize;
                
                nodes.forEach((node, index) => {
                    if (index === 0) return; // Skip source node A
                    if (index === nodes.length - 1) return; // Skip destination node Z
                    
                    // Calculate grid position
                    const gridX = (index - 1) % gridSize;
                    const gridY = Math.floor((index - 1) / gridSize);
                    
                    // Add some randomness within the cell, but keep it dense
                    const jitterX = (Math.random() - 0.5) * cellWidth * 0.5;
                    const jitterY = (Math.random() - 0.5) * cellHeight * 0.5;
                    
                    node.x = (width * 0.2) + (gridX + 0.5) * cellWidth * 0.8 + jitterX;
                    node.y = (height * 0.1) + (gridY + 0.5) * cellHeight + jitterY;
                });
                
                // Place A and Z at strategic positions
                nodes[0].x = width * 0.05; // A at left side
                nodes[0].y = height * 0.5;
                nodes[nodes.length - 1].x = width * 0.95; // Z at right side
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Create links based on range - dense means every node can reach many others
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate sparse topology
            function generateSparseTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 140 }
                ];
                
                // Add regular nodes (original + more nodes for density)
                const regularNodeCount = 88; // Approximately 10x the original minus source/destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: 120
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 140 });
                
                // Position to create sparse network - spread nodes widely
                const gridSize = Math.ceil(Math.sqrt(nodes.length * 1.5)); // Use 150% of normal grid to create sparsity
                const cellWidth = width / gridSize;
                const cellHeight = height / gridSize;
                
                nodes.forEach((node, index) => {
                    if (index === 0) return; // Skip source node A
                    if (index === nodes.length - 1) return; // Skip destination node Z
                    
                    // Calculate grid position
                    const gridX = (index - 1) % gridSize;
                    const gridY = Math.floor((index - 1) / gridSize);
                    
                    // Add significant randomness to create sparsity
                    const jitterX = (Math.random() - 0.5) * cellWidth * 0.9;
                    const jitterY = (Math.random() - 0.5) * cellHeight * 0.9;
                    
                    node.x = (gridX + 0.5) * cellWidth + jitterX;
                    node.y = (gridY + 0.5) * cellHeight + jitterY;
                    
                    // Ensure nodes stay within bounds
                    node.x = Math.max(20, Math.min(width - 20, node.x));
                    node.y = Math.max(20, Math.min(height - 20, node.y));
                });
                
                // Place A and Z at strategic positions
                nodes[0].x = width * 0.05; // A at left side
                nodes[0].y = height * 0.5;
                nodes[nodes.length - 1].x = width * 0.95; // Z at right side
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Create links based on range - sparse means fewer links
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate linear topology
            function generateLinearTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 120 }
                ];
                
                // Add regular nodes (original + more nodes for density)
                const regularNodeCount = 88; // Approximately 10x the original minus source/destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: 120
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 120 });
                
                // Position in a meandering line with some branches
                // Main path nodes
                const mainPathNodes = 40; // About half the nodes form the main path
                const step = width * 0.9 / (mainPathNodes - 1);
                
                for (let i = 0; i < mainPathNodes; i++) {
                    const nodeIndex = i === 0 ? 0 : (i === mainPathNodes - 1 ? nodes.length - 1 : i);
                    nodes[nodeIndex].x = width * 0.05 + (step * i);
                    nodes[nodeIndex].y = height * 0.5 + (Math.sin(i * 0.5) * height * 0.2); // Sinusoidal path
                }
                
                // Position the rest of the nodes as branches off the main path
                for (let i = 1; i < nodes.length - 1; i++) {
                    // Skip nodes already positioned in the main path
                    if (i < mainPathNodes && i !== nodes.length - 1) continue;
                    
                    // Choose a random node from the main path to branch from
                    const branchFrom = Math.floor(Math.random() * mainPathNodes);
                    
                    // Position node as a branch with random angle and distance
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 40 + Math.random() * 80; // Between 40-120px from parent
                    
                    nodes[i].x = nodes[branchFrom === 0 ? 0 : (branchFrom === mainPathNodes - 1 ? nodes.length - 1 : branchFrom)].x + Math.cos(angle) * distance;
                    nodes[i].y = nodes[branchFrom === 0 ? 0 : (branchFrom === mainPathNodes - 1 ? nodes.length - 1 : branchFrom)].y + Math.sin(angle) * distance;
                    
                    // Ensure nodes stay within bounds
                    nodes[i].x = Math.max(20, Math.min(width - 20, nodes[i].x));
                    nodes[i].y = Math.max(20, Math.min(height - 20, nodes[i].y));
                }
                
                // Ensure source and destination are at the ends
                nodes[0].x = width * 0.05;
                nodes[0].y = height * 0.5;
                nodes[nodes.length - 1].x = width * 0.95;
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Create links - for linear, we primarily connect adjacent nodes plus some random cross links
                const links = [];
                
                // Connect main path
                for (let i = 0; i < mainPathNodes - 1; i++) {
                    const sourceIndex = i === 0 ? 0 : i;
                    const targetIndex = i === mainPathNodes - 2 ? nodes.length - 1 : i + 1;
                    
                    links.push({
                        source: nodes[sourceIndex].id,
                        target: nodes[targetIndex].id,
                        distance: 1
                    });
                }
                
                // Add links based on range for the rest of the network
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        // Skip if already connected through main path
                        if (links.some(link => 
                            (link.source === nodes[i].id && link.target === nodes[j].id) || 
                            (link.source === nodes[j].id && link.target === nodes[i].id))) {
                            continue;
                        }
                        
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate star topology
            function generateStarTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 400 }
                ];
                
                // Add regular nodes (original + more nodes for density)
                const regularNodeCount = 88; // Approximately 10x the original minus source/destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: 120
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 120 });
                
                // Select a hub node (E will be our hub)
                const hubIndex = 4; // Index of node E
                nodes[hubIndex].name = 'Node E (Hub)';
                nodes[hubIndex].range = 400; // Increase range for the hub
                
                // Position with hub (E) in the center
                nodes[hubIndex].x = width * 0.5; // E at center
                nodes[hubIndex].y = height * 0.5;
                
                // Position source (A) and destination (Z) at opposite sides
                nodes[0].x = width * 0.05; // A at left
                nodes[0].y = height * 0.5;
                nodes[nodes.length - 1].x = width * 0.95; // Z at right
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Position other nodes in concentric circles around the hub
                const clusters = 5; // Number of clusters
                const nodesPerCluster = Math.ceil((nodes.length - 3) / clusters); // Nodes per cluster, excluding A, E, and Z
                
                let nodeIndex = 1;
                for (let cluster = 0; cluster < clusters; cluster++) {
                    const radius = (cluster + 1) * (Math.min(width, height) * 0.35 / clusters);
                    const nodesInThisCluster = Math.min(nodesPerCluster, nodes.length - 3 - (cluster * nodesPerCluster));
                    
                    for (let i = 0; i < nodesInThisCluster; i++) {
                        if (nodeIndex === hubIndex) {
                            nodeIndex++; // Skip the hub node
                        }
                        
                        if (nodeIndex >= nodes.length - 1) break; // Skip Z (last node)
                        
                        const angle = (i * (2 * Math.PI / nodesInThisCluster));
                        nodes[nodeIndex].x = nodes[hubIndex].x + radius * Math.cos(angle);
                        nodes[nodeIndex].y = nodes[hubIndex].y + radius * Math.sin(angle);
                        
                        nodeIndex++;
                    }
                }
                
                // Create links - everything connects to the center and nearby nodes in same cluster
                const links = [];
                
                // Connect hub to source and destination
                links.push({
                    source: nodes[0].id, // A (source)
                    target: nodes[hubIndex].id, // E (hub)
                    distance: 1
                });
                
                links.push({
                    source: nodes[hubIndex].id, // E (hub)
                    target: nodes[nodes.length - 1].id, // Z (destination)
                    distance: 1
                });
                
                // Connect all nodes to the hub and to nearby nodes based on range
                for (let i = 0; i < nodes.length; i++) {
                    if (i !== hubIndex && i !== 0 && i !== nodes.length - 1) {
                        // Connect to hub if in range
                        if (isInRange(nodes[i], nodes[hubIndex])) {
                            links.push({
                                source: nodes[hubIndex].id,
                                target: nodes[i].id,
                                distance: 1
                            });
                        }
                        
                        // Connect to nearby nodes based on range
                        for (let j = i + 1; j < nodes.length; j++) {
                            if (j !== hubIndex && isInRange(nodes[i], nodes[j])) {
                                links.push({
                                    source: nodes[i].id,
                                    target: nodes[j].id,
                                    distance: 1
                                });
                            }
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Draw the network
            function drawNetwork() {
                // Draw node ranges first so they're in the background
                const nodeRanges = networkGroup.selectAll('.node-range')
                    .data(nodes)
                    .enter()
                    .append('circle')
                    .attr('class', d => `node-range ${d.id === 'A' ? 'meshtastic-range' : d.id === 'Z' ? 'meshcore-range' : ''}`)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', d => d.range)
                    .attr('fill', d => {
                        if (d.type === 'source') return 'rgba(76, 175, 80, 0.1)';
                        if (d.type === 'destination') return 'rgba(233, 30, 99, 0.1)';
                        return 'rgba(200, 200, 200, 0.1)';
                    })
                    .attr('stroke', d => {
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        return '#ccc';
                    });
                
                // Draw links
                const linkElements = networkGroup.selectAll('.network-link')
                    .data(links)
                    .enter()
                    .append('line')
                    .attr('class', 'network-link')
                    .attr('x1', d => nodes.find(n => n.id === d.source).x)
                    .attr('y1', d => nodes.find(n => n.id === d.source).y)
                    .attr('x2', d => nodes.find(n => n.id === d.target).x)
                    .attr('y2', d => nodes.find(n => n.id === d.target).y)
                    .attr('stroke', '#ccc');
                
                // Draw nodes
                const nodeElements = networkGroup.selectAll('.network-node')
                    .data(nodes)
                    .enter()
                    .append('circle')
                    .attr('class', d => `network-node node-${d.id}`)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', d => {
                        // Make source and destination nodes larger
                        if (d.type === 'source' || d.type === 'destination') return 16;
                        // Make hub nodes slightly larger 
                        if (d.id === 'E' || d.name.includes('Hub')) return 14;
                        // Make original nodes (B-H) slightly larger
                        if (d.id.length === 1) return 12;
                        // Make all other nodes smaller
                        return 8;
                    })
                    .attr('fill', d => {
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        if (d.id === 'E' || d.name.includes('Hub')) return '#ff9800';
                        return '#ddd';
                    })
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2)
                    .on('mouseover', function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style('opacity', 0.9);
                        tooltip.html(`${d.name}<br>Range: ${d.range}px`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', function() {
                        tooltip.transition()
                            .duration(500)
                            .style('opacity', 0);
                    });
                
                // Add node labels only for source, destination and original nodes
                const nodeLabels = networkGroup.selectAll('.node-label')
                    .data(nodes.filter(d => d.id.length === 1)) // Only show labels for A-Z nodes
                    .enter()
                    .append('text')
                    .attr('class', 'node-label')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y)
                    .attr('font-size', d => {
                        if (d.type === 'source' || d.type === 'destination') return '14px';
                        if (d.id === 'E' || d.name.includes('Hub')) return '12px';
                        return '10px';
                    })
                    .text(d => d.id);
            }
            
            // Reset metrics display
            function resetMetrics() {
                metrics = {
                    packetsSent: 0,
                    efficiency: 0,
                    deliveryTime: 0,
                    hopsRequired: 0
                };
                
                // Update display
                document.getElementById('metric-packets').textContent = '0';
                document.getElementById('metric-efficiency').textContent = '0%';
                document.getElementById('metric-time').textContent = '0ms';
                document.getElementById('metric-hops').textContent = '0';
            }
            
            // Update metrics
            function updateMetrics(data) {
                // Update metrics object
                Object.assign(metrics, data);
                
                // Update display
                if ('packetsSent' in data) {
                    document.getElementById('metric-packets').textContent = metrics.packetsSent;
                }
                if ('efficiency' in data) {
                    document.getElementById('metric-efficiency').textContent = `${Math.round(metrics.efficiency * 100)}%`;
                }
                if ('deliveryTime' in data) {
                    document.getElementById('metric-time').textContent = `${metrics.deliveryTime}ms`;
                }
                if ('hopsRequired' in data) {
                    document.getElementById('metric-hops').textContent = metrics.hopsRequired;
                }
            }
            
            // Ensure these existing functions take metrics into account
            
            // Utility functions
            function randomPosition(paddingPercent = 0.1) {
                const padding = Math.min(width, height) * paddingPercent;
                return {
                    x: Math.random() * (width - 2 * padding) + padding,
                    y: Math.random() * (height - 2 * padding) + padding
                };
            }
            
            function getRandomRange(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            
            function isInRange(nodeA, nodeB) {
                const dx = nodeA.x - nodeB.x;
                const dy = nodeA.y - nodeB.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                // Nodes are connected if either one's range reaches the other
                return distance <= nodeA.range || distance <= nodeB.range;
            }
            
            // Animation functions
            function createPacket(sourceNode, targetNode, packetClass) {
                const packet = networkGroup.append('circle')
                    .attr('class', `packet ${packetClass}`)
                    .attr('cx', sourceNode.x)
                    .attr('cy', sourceNode.y)
                    .attr('r', 8)
                    .attr('fill-opacity', 0.8);
                
                return packet;
            }
            
            function animatePacket(packet, sourceNode, targetNode, duration, delay, callback) {
                // Create expanding ring effect
                const packetType = packet.attr('class').includes('meshtastic') ? 'meshtastic-ring' :
                                 packet.attr('class').includes('discovery') ? 'discovery-ring' : 
                                 packet.attr('class').includes('meshcore') ? 'meshcore-ring' : 'dropped-ring';
                
                const ring = networkGroup.append('circle')
                    .attr('class', `packet-ring ${packetType}`)
                    .attr('cx', sourceNode.x)
                    .attr('cy', sourceNode.y)
                    .attr('r', 10)
                    .attr('stroke-opacity', 0.8)
                    .attr('stroke-width', 2);
                
                // Animate the expanding ring
                ring.transition()
                    .duration(duration)
                    .attr('r', sourceNode.range)
                    .attr('stroke-opacity', 0)
                    .remove();
                
                // Animate the packet
                packet.transition()
                    .delay(delay)
                    .duration(duration)
                    .attr('cx', targetNode.x)
                    .attr('cy', targetNode.y)
                    .on('end', callback);
                
                return packet;
            }
            
            function createFloodWave(sourceNode, waveClass) {
                const wave = networkGroup.append('circle')
                    .attr('class', `flood-wave ${waveClass}`)
                    .attr('cx', sourceNode.x)
                    .attr('cy', sourceNode.y)
                    .attr('r', 10)
                    .attr('stroke-opacity', 0.8);
                
                // Animate the wave
                wave.transition()
                    .duration(2000)
                    .attr('r', sourceNode.range)
                    .attr('stroke-opacity', 0)
                    .remove();
            }
            
            function highlightOptimalPath() {
                // Find optimal path
                const path = findOptimalPath();
                
                if (path.length < 2) {
                    console.warn("No valid path found to highlight");
                    return;
                }
                
                // Highlight links along the path
                for (let i = 0; i < path.length - 1; i++) {
                    networkGroup.selectAll('.network-link')
                        .filter(d => 
                            (d.source === path[i] && d.target === path[i + 1]) || 
                            (d.target === path[i] && d.source === path[i + 1]))
                        .transition()
                        .duration(500)
                        .attr('stroke', '#43a047') // Meshcore color
                        .attr('stroke-width', 4)
                        .attr('stroke-opacity', 1);
                }
                
                // Highlight nodes along the path
                networkGroup.selectAll('.network-node')
                    .filter(d => path.includes(d.id) && d.id !== 'A' && d.id !== 'Z')
                    .transition()
                    .duration(500)
                    .attr('fill', '#43a047'); // Meshcore color
            }
            
            // Find optimal path based on distance and connections
            function findOptimalPath() {
                // Simple breadth-first search to find a path
                const queue = [{ id: 'A', path: ['A'] }];
                const visited = new Set(['A']);
                
                while (queue.length > 0) {
                    const { id, path } = queue.shift();
                    
                    // If we reached Z, return the path
                    if (id === 'Z') {
                        return path;
                    }
                    
                    // Find all connected nodes
                    const connectedLinks = links.filter(link => 
                        (link.source === id || link.target === id));
                    
                    for (const link of connectedLinks) {
                        const nextId = link.source === id ? link.target : link.source;
                        if (!visited.has(nextId)) {
                            visited.add(nextId);
                            queue.push({ id: nextId, path: [...path, nextId] });
                        }
                    }
                }
                
                // If no path found, return a default path or empty array
                console.warn("No path found between A and Z");
                return [];
            }
            
            // Find optimal path dynamically based on network topology
            const optimalPath = findOptimalPath();
            
            function animateMeshcoreDiscovery() {
                // Reset visualization
                resetVisualization();
                
                // Reset metrics
                resetMetrics();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'MeshCore Path Discovery: Initial radio wave propagation to find the optimal path to the destination.';
                
                // Find nodes by ID
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                // Set to track nodes that have already broadcast during discovery
                const hasNodeBroadcast = new Set(['A']);
                let totalPackets = 0;
                let hasReachedDestination = false;
                
                // Start timing for delivery time metric
                const startTime = Date.now();
                
                // Constants to control flooding visualization
                const MAX_CONCURRENT_ANIMATIONS = 25; // Limit number of concurrent animations
                const MAX_FLOOD_DEPTH = 7; // Limit flood depth for path discovery
                let activeAnimations = 0;
                const animationQueue = [];
                
                // Create a flood wave from source node (only for key nodes)
                if (nodeMap['A'].id.length === 1) {
                    createFloodWave(nodeMap['A'], 'meshcore-wave');
                }
                
                // First wave: from A to all connected nodes
                // Get all links from A
                const aLinks = links.filter(link => link.source === 'A' || link.target === 'A')
                    .map(link => {
                        const targetId = link.source === 'A' ? link.target : link.source;
                        return { sourceId: 'A', targetId };
                    });
                
                // Limit first wave if needed
                let firstWaveLinks = aLinks;
                if (aLinks.length > 8) {
                    // Find direct link to Z if it exists
                    const directToZ = aLinks.find(link => link.targetId === 'Z');
                    
                    // Prioritize original nodes (B-H) and randomly select others
                    const originalNodes = aLinks.filter(link => link.targetId.length === 1 && link.targetId !== 'Z');
                    const otherNodes = aLinks.filter(link => link.targetId.length > 1 && link.targetId !== 'Z');
                    
                    // Shuffle and select subset of other nodes
                    const shuffled = otherNodes.sort(() => 0.5 - Math.random());
                    const selected = shuffled.slice(0, Math.min(7 - originalNodes.length, otherNodes.length));
                    
                    // Combine prioritized links
                    firstWaveLinks = [
                        ...(directToZ ? [directToZ] : []),
                        ...originalNodes,
                        ...selected
                    ].slice(0, 8); // Ensure we don't exceed 8 links
                }
                
                // First wave: from A to connected nodes
                const firstWavePackets = firstWaveLinks.map(link => {
                    const packet = createPacket(nodeMap['A'], nodeMap[link.targetId], 'packet-discovery');
                    
                    // Increment packet count
                    totalPackets++;
                    activeAnimations++;
                    updateMetrics({ packetsSent: totalPackets });
                    
                    return { packet, link };
                });
                
                // Animate first wave
                firstWavePackets.forEach(({ packet, link }, index) => {
                    animatePacket(packet, nodeMap['A'], nodeMap[link.targetId], 500, 300 + (index * 50), function() {
                        // Decrement active animations
                        activeAnimations--;
                        
                        // Mark this node as having broadcast
                        hasNodeBroadcast.add(link.targetId);
                        
                        // Check if this packet reached Z
                        if (link.targetId === 'Z' && !hasReachedDestination) {
                            hasReachedDestination = true;
                            flashDestinationNode();
                        }
                        
                        // If this is the last packet of the first wave, start the second wave
                        if (index === firstWavePackets.length - 1) {
                            setTimeout(function() {
                                animateSecondWave(firstWaveLinks);
                            }, 300);
                        }
                    });
                });
                
                function animateSecondWave(firstWaveLinks) {
                    // Get second wave links (from all nodes except A and Z)
                    const secondWaveLinks = [];
                    firstWaveLinks.forEach(link => {
                        if (link.targetId !== 'Z') { // Skip if we already reached Z
                            const nodeLinks = links.filter(l => 
                                (l.source === link.targetId || l.target === link.targetId) && 
                                l.source !== 'A' && l.target !== 'A');
                            
                            // Limit links per node
                            let nodeLinkSubset = nodeLinks;
                            if (nodeLinks.length > 5) {
                                // Prioritize links to original nodes and Z
                                const linkToZ = nodeLinks.find(nl => 
                                    (nl.source === link.targetId && nl.target === 'Z') || 
                                    (nl.target === link.targetId && nl.source === 'Z'));
                                
                                const originalNodeLinks = nodeLinks.filter(nl => {
                                    const targetId = nl.source === link.targetId ? nl.target : nl.source;
                                    return targetId.length === 1 && targetId !== 'A' && targetId !== 'Z';
                                });
                                
                                const otherLinks = nodeLinks.filter(nl => {
                                    const targetId = nl.source === link.targetId ? nl.target : nl.source;
                                    return targetId.length > 1 && targetId !== 'Z';
                                });
                                
                                // Shuffle and select subset
                                const shuffled = otherLinks.sort(() => 0.5 - Math.random());
                                const selected = shuffled.slice(0, Math.min(4 - originalNodeLinks.length, otherLinks.length));
                                
                                nodeLinkSubset = [
                                    ...(linkToZ ? [linkToZ] : []),
                                    ...originalNodeLinks,
                                    ...selected
                                ].slice(0, 5);
                            }
                            
                            nodeLinkSubset.forEach(nodeLink => {
                                const targetId = nodeLink.source === link.targetId ? nodeLink.target : nodeLink.source;
                                // Don't go backwards and only include if target hasn't broadcast yet
                                if (targetId !== 'A') {
                                    if (hasNodeBroadcast.has(targetId)) {
                                        // Schedule a dropped message effect with slight delay
                                        setTimeout(() => {
                                            showDroppedMessageEffect(nodeMap[targetId]);
                                        }, 300 + Math.random() * 200);
                                    } else {
                                        secondWaveLinks.push({ 
                                            sourceId: link.targetId, 
                                            targetId,
                                            depth: 2
                                        });
                                    }
                                }
                            });
                        }
                    });
                    
                    // Create and animate second wave packets
                    // Handle maximum concurrent animations
                    let processedLinks = 0;
                    const processNextBatch = () => {
                        const currentBatch = secondWaveLinks.slice(
                            processedLinks, 
                            processedLinks + Math.min(MAX_CONCURRENT_ANIMATIONS, secondWaveLinks.length - processedLinks)
                        );
                        
                        if (currentBatch.length === 0) {
                            // All second wave packets processed, start third wave
                            setTimeout(() => animateThirdWave(secondWaveLinks), 800);
                            return;
                        }
                        
                        processedLinks += currentBatch.length;
                        
                        // Create and animate packets for this batch
                        currentBatch.forEach((link, batchIndex) => {
                            // Skip if target has already broadcast
                            if (hasNodeBroadcast.has(link.targetId)) {
                                // Show dropped message effect
                                setTimeout(() => {
                                    showDroppedMessageEffect(nodeMap[link.targetId]);
                                }, 200 + (batchIndex * 30));
                                
                                // If this is the last packet and we're at the end of all batches
                                if (batchIndex === currentBatch.length - 1 && processedLinks >= secondWaveLinks.length) {
                                    // Wait to ensure animations complete, then move to next phase
                                    setTimeout(() => {
                                        if (animationQueue.length === 0) {
                                            animateThirdWave(secondWaveLinks);
                                        }
                                    }, 800);
                                }
                                return;
                            }
                            
                            // Create visual packet with slight delay
                            setTimeout(() => {
                                if (activeAnimations >= MAX_CONCURRENT_ANIMATIONS) {
                                    // Queue for later if too many animations
                                    animationQueue.push(link);
                                    return;
                                }
                                
                                const packet = createPacket(nodeMap[link.sourceId], nodeMap[link.targetId], 'packet-discovery');
                                
                                // Increment counters
                                totalPackets++;
                                activeAnimations++;
                                updateMetrics({ packetsSent: totalPackets });
                                
                                animatePacket(packet, nodeMap[link.sourceId], nodeMap[link.targetId], 500, 0, function() {
                                    // Mark this node as having broadcast
                                    hasNodeBroadcast.add(link.targetId);
                                    
                                    // Decrement animation counter
                                    activeAnimations--;
                                    
                                    // Check if we can process from queue
                                    if (animationQueue.length > 0 && activeAnimations < MAX_CONCURRENT_ANIMATIONS / 2) {
                                        processQueuedAnimations();
                                    }
                                    
                                    // If this packet reached Z and we haven't marked it yet
                                    if (link.targetId === 'Z' && !hasReachedDestination) {
                                        hasReachedDestination = true;
                                        flashDestinationNode();
                                    }
                                    
                                    // If this is the last packet in the batch and we're at the end of all batches
                                    if (batchIndex === currentBatch.length - 1 && processedLinks >= secondWaveLinks.length) {
                                        // Wait to ensure animations complete, then move to next phase
                                        setTimeout(() => {
                                            if (animationQueue.length === 0) {
                                                animateThirdWave(secondWaveLinks);
                                            }
                                        }, 800);
                                    }
                                });
                            }, batchIndex * 30); // Stagger packet creation slightly
                        });
                        
                        // Process next batch if there are more links
                        if (processedLinks < secondWaveLinks.length) {
                            setTimeout(processNextBatch, 300);
                        }
                    };
                    
                    // Start processing second wave in batches
                    processNextBatch();
                }
                
                function animateThirdWave(previousLinks) {
                    // Get third wave links
                    const thirdWaveLinks = [];
                    previousLinks.forEach(prevLink => {
                        // Skip if source is Z (destination reached) or if we've reached our max depth
                        if (prevLink.depth >= MAX_FLOOD_DEPTH) return;
                        
                        const nodeLinks = links.filter(l => 
                            (l.source === prevLink.targetId || l.target === prevLink.targetId) && 
                            l.source !== prevLink.sourceId && l.target !== prevLink.sourceId);
                        
                        // Limit links per node
                        let nodeLinkSubset = nodeLinks.slice(0, 3); // Only take up to 3 links per node for third wave
                        
                        nodeLinkSubset.forEach(nodeLink => {
                            const targetId = nodeLink.source === prevLink.targetId ? nodeLink.target : nodeLink.source;
                            // Only add if the target hasn't broadcast yet
                            if (hasNodeBroadcast.has(targetId)) {
                                // Schedule a dropped message effect with slight delay
                                setTimeout(() => {
                                    showDroppedMessageEffect(nodeMap[targetId]);
                                }, 300 + Math.random() * 200);
                            } else {
                                thirdWaveLinks.push({ 
                                    sourceId: prevLink.targetId, 
                                    targetId, 
                                    depth: prevLink.depth + 1 
                                });
                            }
                        });
                    });
                    
                    // If no more links to traverse, finish the flooding phase
                    if (thirdWaveLinks.length === 0) {
                        finishFloodingPhase();
                        return;
                    }
                    
                    // Process third wave in batches like second wave
                    let processedLinks = 0;
                    const processNextBatch = () => {
                        const currentBatch = thirdWaveLinks.slice(
                            processedLinks, 
                            processedLinks + Math.min(MAX_CONCURRENT_ANIMATIONS, thirdWaveLinks.length - processedLinks)
                        );
                        
                        if (currentBatch.length === 0) {
                            // All third wave packets processed
                            setTimeout(finishFloodingPhase, 800);
                            return;
                        }
                        
                        processedLinks += currentBatch.length;
                        
                        // Create and animate packets for this batch
                        currentBatch.forEach((link, batchIndex) => {
                            // Skip if target has already broadcast
                            if (hasNodeBroadcast.has(link.targetId)) {
                                // Show dropped message effect
                                setTimeout(() => {
                                    showDroppedMessageEffect(nodeMap[link.targetId]);
                                }, 200 + (batchIndex * 30));
                                
                                // If this is the last packet and we're at the end of all batches
                                if (batchIndex === currentBatch.length - 1 && processedLinks >= thirdWaveLinks.length) {
                                    // Wait to ensure animations complete, then finish
                                    setTimeout(() => {
                                        if (animationQueue.length === 0) {
                                            finishFloodingPhase();
                                        }
                                    }, 800);
                                }
                                return;
                            }
                            
                            // Create visual packet with slight delay
                            setTimeout(() => {
                                if (activeAnimations >= MAX_CONCURRENT_ANIMATIONS) {
                                    // Queue for later if too many animations
                                    animationQueue.push(link);
                                    return;
                                }
                                
                                const packet = createPacket(nodeMap[link.sourceId], nodeMap[link.targetId], 'packet-discovery');
                                
                                // Increment counters
                                totalPackets++;
                                activeAnimations++;
                                updateMetrics({ packetsSent: totalPackets });
                                
                                animatePacket(packet, nodeMap[link.sourceId], nodeMap[link.targetId], 500, 0, function() {
                                    // Mark this node as having broadcast
                                    hasNodeBroadcast.add(link.targetId);
                                    
                                    // Decrement animation counter
                                    activeAnimations--;
                                    
                                    // Check if we can process from queue
                                    if (animationQueue.length > 0 && activeAnimations < MAX_CONCURRENT_ANIMATIONS / 2) {
                                        processQueuedAnimations();
                                    }
                                    
                                    // If this packet reached Z and we haven't marked it yet
                                    if (link.targetId === 'Z' && !hasReachedDestination) {
                                        hasReachedDestination = true;
                                        flashDestinationNode();
                                    }
                                    
                                    // If this is the last packet in the batch and we're at the end of all batches
                                    if (batchIndex === currentBatch.length - 1 && processedLinks >= thirdWaveLinks.length) {
                                        // Wait to ensure animations complete, then finish
                                        setTimeout(() => {
                                            if (animationQueue.length === 0) {
                                                finishFloodingPhase();
                                            }
                                        }, 800);
                                    }
                                });
                            }, batchIndex * 30); // Stagger packet creation slightly
                        });
                        
                        // Process next batch if there are more links
                        if (processedLinks < thirdWaveLinks.length) {
                            setTimeout(processNextBatch, 300);
                        }
                    };
                    
                    // Start processing third wave in batches
                    processNextBatch();
                }
                
                function processQueuedAnimations() {
                    // Process from queue if there are items and we have capacity
                    while (animationQueue.length > 0 && activeAnimations < MAX_CONCURRENT_ANIMATIONS / 2) {
                        const link = animationQueue.shift();
                        
                        // Skip if target has already broadcast
                        if (hasNodeBroadcast.has(link.targetId)) {
                            // Show dropped message effect
                            showDroppedMessageEffect(nodeMap[link.targetId]);
                            continue;
                        }
                        
                        const packet = createPacket(nodeMap[link.sourceId], nodeMap[link.targetId], 'packet-discovery');
                        
                        // Increment counters
                        totalPackets++;
                        activeAnimations++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        animatePacket(packet, nodeMap[link.sourceId], nodeMap[link.targetId], 500, 0, function() {
                            // Mark this node as having broadcast
                            hasNodeBroadcast.add(link.targetId);
                            
                            // Decrement animation counter
                            activeAnimations--;
                            
                            // If this packet reached Z and we haven't marked it yet
                            if (link.targetId === 'Z' && !hasReachedDestination) {
                                hasReachedDestination = true;
                                flashDestinationNode();
                            }
                            
                            // Continue processing queue
                            if (animationQueue.length > 0) {
                                processQueuedAnimations();
                            }
                        });
                    }
                    
                    // If there are still items in the queue but we're at capacity, check again later
                    if (animationQueue.length > 0) {
                        setTimeout(processQueuedAnimations, 500);
                    }
                }
                
                function flashDestinationNode() {
                    // Flash destination node to indicate receipt
                    networkGroup.selectAll('.network-node')
                        .filter(d => d.id === 'Z')
                        .transition()
                        .duration(300)
                        .attr('r', d => d.type === 'destination' ? 20 : 14)
                        .transition()
                        .duration(300)
                        .attr('r', d => d.type === 'destination' ? 16 : 12);
                        
                    // Update caption to indicate destination reached but flooding continues
                    document.getElementById('phase-caption').innerText = 
                        'MeshCore Path Discovery: Destination reached, but flooding continues throughout the network.';
                }
                
                function finishFloodingPhase() {
                    setTimeout(function() {
                        // Calculate discovery phase metrics
                        const discoveryTime = Date.now() - startTime;
                        
                        // Update metrics for discovery phase
                        updateMetrics({
                            deliveryTime: discoveryTime
                        });
                        
                        // Find the optimal path
                        const optimalPath = findOptimalPath();
                        
                        // Update caption to show ACK phase
                        document.getElementById('phase-caption').innerText = 
                            'MeshCore Path Discovery: Flooding complete. Sending ACK with optimal path information back to source.';
                        
                        // Highlight the optimal path
                        highlightOptimalPath();
                        
                        // Send ACK packets back along the optimal path from Z to A
                        if (optimalPath.length >= 2) {
                            // Create a slight delay before starting ACK process
                            setTimeout(function() {
                                animatePathAck(optimalPath);
                            }, 1000);
                        } else {
                            // No valid path found
                            document.getElementById('phase-caption').innerText = 
                                'No valid path found between source and destination.';
                        }
                    }, 1000);
                }
                
                // Function to animate acknowledgment packets returning along the optimal path
                function animatePathAck(path) {
                    // Reverse the path to go from Z to A
                    const reversePath = [...path].reverse();
                    
                    // Create and animate ACK packets along the path
                    animateAckSegment(0);
                    
                    function animateAckSegment(currentIndex) {
                        if (currentIndex >= reversePath.length - 1) {
                            // We've reached the source node, route is established
                            
                            // Highlight source node to indicate receipt of ACK
                            networkGroup.selectAll('.network-node')
                                .filter(d => d.id === 'A')
                                .transition()
                                .duration(300)
                                .attr('r', d => d.type === 'source' ? 20 : 14)
                                .transition()
                                .duration(300)
                                .attr('r', d => d.type === 'source' ? 16 : 12);
                            
                            // Update caption
                            document.getElementById('phase-caption').innerText = 
                                'MeshCore Path Discovery: Route established! The source now knows the optimal path to the destination.';
                            
                            return;
                        }
                        
                        // Get current segment nodes
                        const sourceId = reversePath[currentIndex];
                        const targetId = reversePath[currentIndex + 1];
                        
                        // Create ACK packet with special styling
                        const ackPacket = networkGroup.append('circle')
                            .attr('class', 'packet packet-ack')
                            .attr('cx', nodeMap[sourceId].x)
                            .attr('cy', nodeMap[sourceId].y)
                            .attr('r', 8)
                            .attr('fill', '#9c27b0') // Purple color for ACK packets
                            .attr('fill-opacity', 0.8)
                            .attr('stroke', '#fff')
                            .attr('stroke-width', 2);
                        
                        // Add a special ring effect for ACK
                        const ring = networkGroup.append('circle')
                            .attr('class', 'packet-ring ack-ring')
                            .attr('cx', nodeMap[sourceId].x)
                            .attr('cy', nodeMap[sourceId].y)
                            .attr('r', 10)
                            .attr('stroke', '#9c27b0')
                            .attr('stroke-opacity', 0.8)
                            .attr('stroke-width', 2)
                            .attr('fill', 'none');
                        
                        // Animate the ring
                        ring.transition()
                            .duration(500)
                            .attr('r', nodeMap[sourceId].range * 0.5)
                            .attr('stroke-opacity', 0)
                            .remove();
                        
                        // Increment packet count for the ACK
                        totalPackets++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        // Animate the ACK packet
                        ackPacket.transition()
                            .duration(600)
                            .attr('cx', nodeMap[targetId].x)
                            .attr('cy', nodeMap[targetId].y)
                            .on('end', function() {
                                // Flash the receiving node to indicate receipt
                                networkGroup.selectAll('.network-node')
                                    .filter(d => d.id === targetId)
                                    .transition()
                                    .duration(200)
                                    .attr('r', d => {
                                        if (d.type === 'source') return 20;
                                        if (d.id.length === 1) return 16;
                                        return 12;
                                    })
                                    .transition()
                                    .duration(200)
                                    .attr('r', d => {
                                        if (d.type === 'source') return 16;
                                        if (d.id.length === 1) return 12;
                                        return 8;
                                    });
                                
                                // Remove the ACK packet
                                d3.select(this).remove();
                                
                                // Continue to next segment
                                setTimeout(function() {
                                    animateAckSegment(currentIndex + 1);
                                }, 400);
                            });
                    }
                }
            }
            
            function animateMeshcoreDirectRouting() {
                // Reset visualization but keep optimal path highlighted
                resetVisualization(false);
                
                // Reset metrics but keep discovery metrics (if any)
                const discoveryTime = metrics.deliveryTime;
                const discoveryPackets = metrics.packetsSent;
                resetMetrics();
                updateMetrics({ 
                    packetsSent: discoveryPackets || 0,
                    deliveryTime: discoveryTime || 0
                });
                
                // Make sure optimal path is highlighted
                highlightOptimalPath();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'MeshCore Direct Routing: After discovery, radio signals follow only the established optimal path. Nodes not on the path drop signals.';
                
                // Find nodes by ID
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                // Start timing for direct routing phase
                const startTime = Date.now();
                let directPackets = 0;
                let hasReachedDestination = false;
                
                // Get optimal path for direct routing
                const optimalPath = findOptimalPath();
                
                // Animate direct route along optimal path
                if (optimalPath.length >= 2) {
                    // Show direct routing along optimal path
                    animateDirectPath(0);
                    
                    // After a delay, show dropped packets from nodes not on the path
                    setTimeout(showDroppedPackets, 3000);
                } else {
                    document.getElementById('phase-caption').innerText = 
                        'No valid path found between source and destination. Try refreshing to generate a new network.';
                }
                
                function animateDirectPath(currentIndex) {
                    if (currentIndex >= optimalPath.length - 1) {
                        // We've reached the destination
                        if (!hasReachedDestination) {
                            hasReachedDestination = true;
                            
                            // Calculate direct routing metrics
                            const directTime = Date.now() - startTime;
                            const totalTime = directTime + (discoveryTime || 0);
                            const hopsRequired = optimalPath.length - 1;
                            const totalPackets = (discoveryPackets || 0) + directPackets;
                            
                            // Calculate efficiency ratio (optimal path / total packets)
                            const efficiency = hopsRequired / totalPackets;
                            
                            // Update metrics
                            updateMetrics({
                                packetsSent: totalPackets,
                                deliveryTime: totalTime,
                                hopsRequired: hopsRequired,
                                efficiency: efficiency
                            });
                        }
                        
                        // Flash the destination node to show success
                        networkGroup.selectAll('.network-node')
                            .filter(d => d.id === 'Z')
                            .transition()
                            .duration(300)
                            .attr('r', d => d.type === 'destination' ? 20 : 14)
                            .attr('fill', '#4caf50')
                            .transition()
                            .duration(300)
                            .attr('r', d => d.type === 'destination' ? 16 : 12)
                            .attr('fill', '#e91e63');
                        
                        // After a delay, repeat the direct path demonstration
                        setTimeout(function() {
                            animateDirectPath(0);
                        }, 1500);
                        
                        return;
                    }
                    
                    // Create and animate packet along the current segment of the path
                    const sourceId = optimalPath[currentIndex];
                    const targetId = optimalPath[currentIndex + 1];
                    
                    const packet = createPacket(nodeMap[sourceId], nodeMap[targetId], 'packet-meshcore');
                    
                    // Increment packet count
                    directPackets++;
                    updateMetrics({ packetsSent: (discoveryPackets || 0) + directPackets });
                    
                    animatePacket(packet, nodeMap[sourceId], nodeMap[targetId], 500, 300, function() {
                        // Continue to the next segment
                        animateDirectPath(currentIndex + 1);
                    });
                }
                
                function showDroppedPackets() {
                    // Find a few nodes that are not on the optimal path but connected to nodes that are
                    const offPathConnections = [];
                    
                    // Set of nodes in the optimal path
                    const optimalPathNodeSet = new Set(optimalPath);
                    
                    // Look at each node in the optimal path
                    for (let i = 0; i < optimalPath.length; i++) {
                        const pathNodeId = optimalPath[i];
                        
                        // Find links where one end is this path node
                        const connectedLinks = links.filter(link => 
                            (link.source === pathNodeId || link.target === pathNodeId));
                        
                        // For each link, check if the other end is not in the optimal path
                        connectedLinks.forEach(link => {
                            const otherId = link.source === pathNodeId ? link.target : link.source;
                            
                            if (!optimalPathNodeSet.has(otherId)) {
                                offPathConnections.push({
                                    pathNodeId,
                                    offPathNodeId: otherId
                                });
                            }
                        });
                        
                        // Limit to 3 connections to avoid visual clutter
                        if (offPathConnections.length >= 3) break;
                    }
                    
                    // If we found any, animate dropped packets
                    if (offPathConnections.length > 0) {
                        // Update caption to explain dropped packets
                        document.getElementById('phase-caption').innerText = 
                            'MeshCore Direct Routing: Nodes not on the established route drop packets, ensuring bandwidth efficiency.';
                        
                        // Animate up to 3 dropped packets
                        const droppedCount = Math.min(offPathConnections.length, 3);
                        
                        for (let i = 0; i < droppedCount; i++) {
                            const connection = offPathConnections[i];
                            
                            // Create and animate a dropped packet
                            setTimeout(() => {
                                const droppedPacket = createPacket(
                                    nodeMap[connection.pathNodeId], 
                                    nodeMap[connection.offPathNodeId], 
                                    'packet-dropped'
                                );
                                
                                // Increment packet count
                                directPackets++;
                                updateMetrics({ packetsSent: (discoveryPackets || 0) + directPackets });
                                
                                animatePacket(droppedPacket, nodeMap[connection.pathNodeId], nodeMap[connection.offPathNodeId], 500, 200, function() {
                                    // Show packet being dropped
                                    d3.select(this)
                                        .transition()
                                        .duration(200)
                                        .attr('r', 0)
                                        .attr('fill-opacity', 0);
                                });
                            }, i * 800); // Stagger the dropped packets
                        }
                    }
                }
            }
            
            function animateMeshtasticFlooding() {
                // Reset visualization
                resetVisualization();
                
                // Reset metrics
                resetMetrics();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'Meshtastic Flooding: Radio signals propagate through all nodes within range, which rebroadcast once per message to maximize delivery probability.';
                
                // Find nodes by ID
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                // Set to track nodes that have already broadcast (not just visited)
                const hasNodeBroadcast = new Set(['A']);
                const rebroadcastQueue = [];
                
                // Start timing for delivery time metric
                const startTime = Date.now();
                let hasReachedDestination = false;
                let totalPackets = 0;
                
                // Constants to control flooding visualization
                const MAX_CONCURRENT_ANIMATIONS = 25; // Limit number of concurrent animations
                const MAX_FLOOD_DEPTH = 7; // Meshtastic is limited to 7 hops
                let activeAnimations = 0;
                
                // Start flood from node A with visible waves
                floodFromNode('A', 0);
                
                function floodFromNode(nodeId, depth) {
                    if (depth > MAX_FLOOD_DEPTH) return; // Limit recursion depth
                    
                    const sourceNode = nodes.find(n => n.id === nodeId);
                    
                    // Create a visible flood wave from this node if it's a key node
                    // Only show waves for original nodes (A-Z) to reduce visual clutter
                    if (nodeId.length === 1) {
                        createFloodWave(sourceNode, 'meshtastic-wave');
                    }
                    
                    // Mark this node as having broadcast
                    hasNodeBroadcast.add(nodeId);
                    
                    // Get all connections for this node
                    const nodeLinks = links.filter(link => 
                        link.source === nodeId || link.target === nodeId);
                    
                    // Limit the number of visualized connections for performance
                    // For nodes with many connections, select a subset
                    let selectedLinks = nodeLinks;
                    if (nodeLinks.length > 5) {
                        // Always include the direct path to Z if it exists
                        const directToZ = nodeLinks.find(link => 
                            (link.source === nodeId && link.target === 'Z') || 
                            (link.target === nodeId && link.source === 'Z'));
                        
                        // Randomly select a subset of links
                        const otherLinks = nodeLinks.filter(link => 
                            !((link.source === nodeId && link.target === 'Z') || 
                            (link.target === nodeId && link.source === 'Z')));
                        
                        const shuffled = otherLinks.sort(() => 0.5 - Math.random());
                        const selected = shuffled.slice(0, 4); // Take up to 4 random connections
                        
                        selectedLinks = directToZ ? [directToZ, ...selected] : selected;
                    }
                    
                    // Create a packet for each selected connection
                    selectedLinks.forEach((link, index) => {
                        const targetId = link.source === nodeId ? link.target : link.source;
                        
                        // Check if target has already broadcast - if so, show dropped message effect
                        if (hasNodeBroadcast.has(targetId)) {
                            setTimeout(() => {
                                showDroppedMessageEffect(nodeMap[targetId]);
                            }, 200 + (index * 100));
                            return;
                        }
                        
                        // Check if we're already at the animation limit
                        if (activeAnimations >= MAX_CONCURRENT_ANIMATIONS) {
                            // Queue this animation for later only if target hasn't broadcast yet
                            if (!hasNodeBroadcast.has(targetId)) {
                                rebroadcastQueue.push({
                                    sourceId: nodeId,
                                    targetId: targetId,
                                    depth: depth,
                                    delay: 300
                                });
                            }
                            return;
                        }
                        
                        // Create and animate packet with enhanced rings
                        const packet = createPacket(nodeMap[nodeId], nodeMap[targetId], 'packet-meshtastic');
                        
                        // Increment packet count and active animations
                        totalPackets++;
                        activeAnimations++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        animatePacket(packet, nodeMap[nodeId], nodeMap[targetId], 800, 200 + (index * 100), function() {
                            // Decrement active animations count
                            activeAnimations--;
                            
                            // Schedule the next wave only if this node hasn't broadcast before
                            if (!hasNodeBroadcast.has(targetId)) {
                                rebroadcastQueue.push({
                                    sourceId: targetId,
                                    targetId: null, // No specific target for flooding
                                    depth: depth + 1,
                                    delay: 500
                                });
                            }
                            
                            // Process the queue immediately if we're below the animation limit
                            if (activeAnimations < MAX_CONCURRENT_ANIMATIONS / 2) {
                                processRebroadcastQueue();
                            }
                            
                            // If we reached Z, show success effect and update metrics
                            if (targetId === 'Z' && !hasReachedDestination) {
                                hasReachedDestination = true;
                                
                                // Calculate delivery time
                                const deliveryTime = Date.now() - startTime;
                                
                                // Calculate hop count (by depth)
                                const hopsRequired = depth + 1;
                                
                                // Calculate efficiency (optimal path / total packets)
                                // A lower ratio means more network congestion
                                const optimalPath = findOptimalPath();
                                const efficiency = optimalPath.length > 0 ? 
                                    (optimalPath.length - 1) / totalPackets : 0;
                                
                                // Update metrics
                                updateMetrics({
                                    deliveryTime: deliveryTime,
                                    hopsRequired: hopsRequired,
                                    efficiency: efficiency
                                });
                                
                                // Flash the destination node
                                networkGroup.selectAll('.network-node')
                                    .filter(d => d.id === 'Z')
                                    .transition()
                                    .duration(300)
                                    .attr('r', d => d.type === 'destination' ? 20 : 14)
                                    .attr('fill', '#4caf50')
                                    .transition()
                                    .duration(300)
                                    .attr('r', d => d.type === 'destination' ? 16 : 12)
                                    .attr('fill', '#e91e63');
                                
                                // Update caption to indicate message arrived but flooding continues
                                document.getElementById('phase-caption').innerText = 
                                    'Meshtastic Flooding: Message reached destination, but flooding continues up to 7 hops.';
                            }
                        });
                    });
                    
                    // Process queue after a delay if no animations were started
                    if (activeAnimations === 0) {
                        setTimeout(processRebroadcastQueue, 500);
                    }
                }
                
                function processRebroadcastQueue() {
                    // Process up to the max concurrent animations limit
                    let processed = 0;
                    
                    while (rebroadcastQueue.length > 0 && activeAnimations < MAX_CONCURRENT_ANIMATIONS && processed < 5) {
                        const nextBroadcast = rebroadcastQueue.shift();
                        processed++;
                        
                        if (nextBroadcast.targetId === null) {
                            // This is a flooding request, only process if node hasn't broadcast yet
                            if (!hasNodeBroadcast.has(nextBroadcast.sourceId)) {
                                setTimeout(function() {
                                    floodFromNode(nextBroadcast.sourceId, nextBroadcast.depth);
                                }, nextBroadcast.delay);
                            }
                        } else {
                            // This is a directed packet, check if target has already broadcast
                            if (hasNodeBroadcast.has(nextBroadcast.targetId)) {
                                // Show dropped message effect
                                setTimeout(() => {
                                    showDroppedMessageEffect(nodeMap[nextBroadcast.targetId]);
                                }, 200);
                                continue;
                            }
                            
                            // Create and animate packet
                            const packet = createPacket(nodeMap[nextBroadcast.sourceId], nodeMap[nextBroadcast.targetId], 'packet-meshtastic');
                            
                            // Increment packet count and active animations
                            totalPackets++;
                            activeAnimations++;
                            updateMetrics({ packetsSent: totalPackets });
                            
                            animatePacket(packet, nodeMap[nextBroadcast.sourceId], nodeMap[nextBroadcast.targetId], 800, 0, function() {
                                // Decrement active animations count
                                activeAnimations--;
                                
                                // Schedule the next wave only if this node hasn't broadcast yet
                                if (!hasNodeBroadcast.has(nextBroadcast.targetId)) {
                                    rebroadcastQueue.push({
                                        sourceId: nextBroadcast.targetId,
                                        targetId: null,
                                        depth: nextBroadcast.depth + 1,
                                        delay: 300
                                    });
                                }
                                
                                // If we reached Z, update metrics
                                if (nextBroadcast.targetId === 'Z' && !hasReachedDestination) {
                                    hasReachedDestination = true;
                                    
                                    // Calculate metrics
                                    const deliveryTime = Date.now() - startTime;
                                    const hopsRequired = nextBroadcast.depth + 1;
                                    const optimalPath = findOptimalPath();
                                    const efficiency = optimalPath.length > 0 ? 
                                        (optimalPath.length - 1) / totalPackets : 0;
                                    
                                    updateMetrics({
                                        deliveryTime: deliveryTime,
                                        hopsRequired: hopsRequired,
                                        efficiency: efficiency
                                    });
                                    
                                    // Flash the destination node
                                    networkGroup.selectAll('.network-node')
                                        .filter(d => d.id === 'Z')
                                        .transition()
                                        .duration(300)
                                        .attr('r', d => d.type === 'destination' ? 20 : 14)
                                        .attr('fill', '#4caf50')
                                        .transition()
                                        .duration(300)
                                        .attr('r', d => d.type === 'destination' ? 16 : 12)
                                        .attr('fill', '#e91e63');
                                    
                                    // Update caption
                                    document.getElementById('phase-caption').innerText = 
                                        'Meshtastic Flooding: Message reached destination, but flooding continues up to 7 hops.';
                                }
                                
                                // Process more from the queue
                                if (rebroadcastQueue.length > 0) {
                                    processRebroadcastQueue();
                                }
                            });
                        }
                    }
                    
                    // If there are still items in the queue, schedule another processing round
                    if (rebroadcastQueue.length > 0) {
                        setTimeout(processRebroadcastQueue, 800);
                    }
                }
            }
            
            function resetVisualization(clearOptimalPath = true) {
                // Remove all packets
                networkGroup.selectAll('.packet, .packet-ring, .flood-wave').remove();
                
                // Clear any existing animations
                d3.selectAll('.packet').interrupt();
                d3.selectAll('.network-node').interrupt();
                
                // Reset node colors
                networkGroup.selectAll('.network-node')
                    .transition()
                    .duration(300)
                    .attr('fill', d => {
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        if (d.id === 'E' || d.name.includes('Hub')) return '#ff9800';
                        return '#ddd';
                    })
                    .attr('r', d => {
                        // Make source and destination nodes larger
                        if (d.type === 'source' || d.type === 'destination') return 16;
                        // Make hub nodes slightly larger
                        if (d.id === 'E' || d.name.includes('Hub')) return 14;
                        // Make original nodes (B-H) slightly larger
                        if (d.id.length === 1) return 12;
                        // Make all other nodes smaller
                        return 8;
                    });
                
                // Clear optimal path highlighting if requested
                if (clearOptimalPath) {
                    networkGroup.selectAll('.network-link')
                        .transition()
                        .duration(300)
                        .attr('stroke', '#ccc')
                        .attr('stroke-width', 2)
                        .attr('stroke-opacity', 0.6);
                }
            }
            
            function animateComparison() {
                // Reset visualization
                resetVisualization();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'Side-by-Side Comparison: Meshtastic flooding (left) vs MeshCore selective routing (right)';
                
                // Split the visualization into two parts
                const splitWidth = width / 2;
                
                // Create comparison container
                const comparisonContainer = d3.select('#network-visualization')
                    .append('div')
                    .attr('class', 'comparison-container')
                    .style('display', 'flex')
                    .style('width', '100%')
                    .style('height', '100%');
                
                // Create left view (Meshtastic)
                const leftView = comparisonContainer
                    .append('div')
                    .attr('class', 'comparison-view left-view')
                    .style('width', '50%')
                    .style('height', '100%')
                    .style('position', 'relative')
                    .style('border-right', '1px dashed #ccc');
                
                // Create right view (MeshCore)
                const rightView = comparisonContainer
                    .append('div')
                    .attr('class', 'comparison-view right-view')
                    .style('width', '50%')
                    .style('height', '100%')
                    .style('position', 'relative');
                
                // Create SVG for left view
                const leftSvg = leftView
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%');
                
                // Create SVG for right view
                const rightSvg = rightView
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%');
                
                // Add labels
                leftView.append('div')
                    .attr('class', 'view-label')
                    .style('position', 'absolute')
                    .style('top', '10px')
                    .style('left', '10px')
                    .style('background-color', 'rgba(30, 136, 229, 0.9)')
                    .style('color', 'white')
                    .style('padding', '5px 10px')
                    .style('border-radius', '4px')
                    .style('font-weight', 'bold')
                    .text('Meshtastic Flooding');
                
                rightView.append('div')
                    .attr('class', 'view-label')
                    .style('position', 'absolute')
                    .style('top', '10px')
                    .style('left', '10px')
                    .style('background-color', 'rgba(67, 160, 71, 0.9)')
                    .style('color', 'white')
                    .style('padding', '5px 10px')
                    .style('border-radius', '4px')
                    .style('font-weight', 'bold')
                    .text('MeshCore Selective Routing');
                
                // Add metrics displays
                const leftMetrics = leftView.append('div')
                    .attr('class', 'view-metrics')
                    .style('position', 'absolute')
                    .style('bottom', '10px')
                    .style('left', '10px')
                    .style('right', '10px')
                    .style('background-color', 'rgba(255, 255, 255, 0.9)')
                    .style('padding', '5px')
                    .style('border-radius', '4px')
                    .style('font-size', '0.9em');
                
                const rightMetrics = rightView.append('div')
                    .attr('class', 'view-metrics')
                    .style('position', 'absolute')
                    .style('bottom', '10px')
                    .style('left', '10px')
                    .style('right', '10px')
                    .style('background-color', 'rgba(255, 255, 255, 0.9)')
                    .style('padding', '5px')
                    .style('border-radius', '4px')
                    .style('font-size', '0.9em');
                
                leftMetrics.html('<b>Packets:</b> <span id="left-packets">0</span> | <b>Efficiency:</b> <span id="left-efficiency">0%</span> | <b>Time:</b> <span id="left-time">0ms</span>');
                rightMetrics.html('<b>Packets:</b> <span id="right-packets">0</span> | <b>Efficiency:</b> <span id="right-efficiency">0%</span> | <b>Time:</b> <span id="right-time">0ms</span>');
                
                // Hide main SVG
                svg.style('display', 'none');
                
                // Add start button
                const startButton = d3.select('#network-visualization')
                    .append('button')
                    .attr('class', 'start-comparison-button')
                    .style('position', 'absolute')
                    .style('top', '50%')
                    .style('left', '50%')
                    .style('transform', 'translate(-50%, -50%)')
                    .style('z-index', '100')
                    .style('padding', '10px 20px')
                    .style('background-color', '#e74c3c')
                    .style('color', 'white')
                    .style('border', 'none')
                    .style('border-radius', '5px')
                    .style('font-weight', 'bold')
                    .style('cursor', 'pointer')
                    .text('Start Comparison');
                
                // Add exit button
                const exitButton = d3.select('#network-visualization')
                    .append('button')
                    .attr('class', 'exit-comparison-button')
                    .style('position', 'absolute')
                    .style('top', '10px')
                    .style('right', '10px')
                    .style('z-index', '100')
                    .style('padding', '5px 10px')
                    .style('background-color', '#6c757d')
                    .style('color', 'white')
                    .style('border', 'none')
                    .style('border-radius', '5px')
                    .style('font-weight', 'bold')
                    .style('cursor', 'pointer')
                    .text('Exit Comparison')
                    .on('click', exitComparisonView);
                
                startButton.on('click', function() {
                    // Hide the button
                    d3.select(this).style('display', 'none');
                    
                    // Run animations simultaneously
                    setTimeout(() => {
                        // This is a simplified version showing the concept
                        alert('For a full comparison, please run the individual animations. The side-by-side comparison requires significant refactoring of the visualization code.');
                        
                        // For a proper implementation, you would need to:
                        // 1. Clone the network generation code to create two separate networks
                        // 2. Refactor the animation functions to take an SVG container as parameter
                        // 3. Run the animations in parallel on both networks
                    }, 100);
                });
            }
            
            function exitComparisonView() {
                // Remove comparison elements
                d3.select('.comparison-container').remove();
                d3.select('.start-comparison-button').remove();
                d3.select('.exit-comparison-button').remove();
                
                // Show main SVG again
                svg.style('display', 'block');
                
                // Reset the visualization
                resetVisualization();
                
                // Reset active button state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById('btn-meshtastic').classList.add('active');
                
                // Reset caption
                document.getElementById('phase-caption').innerText = 
                    'Select a routing method to visualize different approaches to mesh networking.';
                
                // Reset metrics
                resetMetrics();
            }
            
            // Start with Meshtastic flooding by default
            setTimeout(animateMeshtasticFlooding, 500);
            
            // Add this function after createFloodWave and before animateMeshtasticFlooding
            function showDroppedMessageEffect(node) {
                // Check if we got a valid node
                if (!node) return;
                
                // Create a red flash effect
                const flash = networkGroup.append('circle')
                    .attr('class', 'packet-dropped-flash')
                    .attr('cx', node.x)
                    .attr('cy', node.y)
                    .attr('r', 0)
                    .attr('fill', '#dc3545')
                    .attr('fill-opacity', 0.6)
                    .attr('stroke', '#dc3545')
                    .attr('stroke-width', 2)
                    .attr('stroke-opacity', 0.8);
                
                // Animate the flash
                flash.transition()
                    .duration(300)
                    .attr('r', 15)
                    .attr('fill-opacity', 0.4)
                    .transition()
                    .duration(200)
                    .attr('r', 0)
                    .attr('fill-opacity', 0)
                    .remove();
            }
        });
        
        // Add smooth scrolling and other UI functionality
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    window.scrollTo({
                        top: target.offsetTop - 70,
                        behavior: 'smooth'
                    });
                }
            });
        });
    </script>
</body>
</html> 