<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Network Routing Visualization</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Specific styles for the D3 visualization */
        .visualization-container {
            margin: 2rem auto;
            width: 100%;
            max-width: 1000px;
            height: 500px;
            border-radius: var(--border-radius);
            background-color: #f8f9fa;
            box-shadow: var(--card-shadow);
            position: relative;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin: 1rem 0 2rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .control-button {
            padding: 8px 16px;
            background-color: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-button:hover {
            border-color: #aaa;
            transform: translateY(-2px);
        }
        
        .control-button.meshtastic {
            border-color: var(--meshtastic-color);
        }
        
        .control-button.meshtastic.active {
            background-color: var(--meshtastic-color);
            color: white;
        }
        
        .control-button.meshcore {
            border-color: var(--meshcore-color);
        }
        
        .control-button.meshcore.active {
            background-color: var(--meshcore-color);
            color: white;
        }
        
        .control-button.action {
            border-color: var(--accent-color);
        }
        
        .control-button.action.active {
            background-color: var(--accent-color);
            color: white;
        }
        
        .phase-caption {
            text-align: center;
            padding: 1rem;
            margin-top: 1rem;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: var(--border-radius);
            max-width: 600px;
            margin: 0 auto;
            font-weight: 500;
            border-left: 4px solid var(--accent-color);
        }
        
        .network-node {
            cursor: pointer;
        }
        
        .node-label {
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        
        .network-link {
            stroke-width: 2;
            stroke-opacity: 0.6;
        }
        
        .packet {
            fill-opacity: 0.8;
        }
        
        .packet-meshtastic {
            fill: var(--meshtastic-color);
        }
        
        .packet-meshcore {
            fill: var(--meshcore-color);
        }
        
        .packet-discovery {
            fill: #fd7e14;
        }
        
        .packet-dropped {
            fill: #dc3545;
        }
        
        .packet-ack {
            fill: #9c27b0;  /* Purple color for ACK packets */
            stroke: #fff;
            stroke-width: 2;
        }
        
        /* Expanding ring styles */
        .packet-ring {
            fill: none;
            stroke-width: 2;
            pointer-events: none;
        }
        
        .packet-ring.meshtastic-ring {
            stroke: var(--meshtastic-color);
        }
        
        .packet-ring.meshcore-ring {
            stroke: var(--meshcore-color);
        }
        
        .packet-ring.discovery-ring {
            stroke: #fd7e14;
        }
        
        .packet-ring.dropped-ring {
            stroke: #dc3545;
        }
        
        .packet-ring.ack-ring {
            stroke: #9c27b0;  /* Purple color for ACK rings */
            stroke-dasharray: 3,3;  /* Dashed stroke for ACK rings */
        }
        
        /* Flood wave animation */
        .flood-wave {
            fill: none;
            stroke-width: 3;
            pointer-events: none;
        }
        
        .flood-wave.meshtastic-wave {
            stroke: var(--meshtastic-color);
        }
        
        .flood-wave.meshcore-wave {
            stroke: var(--meshcore-color);
        }
        
        .node-range {
            fill-opacity: 0.1;
            stroke-opacity: 0.3;
            stroke-width: 1;
            stroke-dasharray: 5,5;
            pointer-events: none;
        }
        
        .meshtastic-range {
            fill: var(--meshtastic-color);
            stroke: var(--meshtastic-color);
        }
        
        .meshcore-range {
            fill: var(--meshcore-color);
            stroke: var(--meshcore-color);
        }
        
        .tooltip {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            pointer-events: none;
            font-size: 14px;
            z-index: 100;
            transition: opacity 0.3s;
        }
        
        .compare-container {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .compare-item {
            flex: 1 1 calc(50% - 1rem);
            min-width: 280px;
            background-color: #fff;
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            padding: 1.5rem;
        }
        
        .compare-item h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
            text-align: center;
        }
        
        .compare-meshtastic h3 {
            border-color: var(--meshtastic-color);
            color: var(--meshtastic-color);
        }
        
        .compare-meshcore h3 {
            border-color: var(--meshcore-color);
            color: var(--meshcore-color);
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 1rem 0;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        
        /* Network Topology Selector Styles */
        .network-topology-selector {
            margin: 1.5rem 0;
            text-align: center;
            background-color: #fff;
            padding: 1rem;
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
        }
        
        .network-topology-selector h4 {
            margin: 0 0 0.5rem 0;
            color: var(--header-bg-color);
        }
        
        .topology-buttons {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        .topology-button {
            padding: 0.5rem 1rem;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .topology-button:hover {
            background-color: #e9ecef;
            transform: translateY(-2px);
        }
        
        .topology-button.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        /* Metrics Display Styles */
        .performance-metrics {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .metric-card {
            flex: 1;
            min-width: 150px;
            background-color: #fff;
            padding: 0.75rem;
            border-radius: var(--border-radius);
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0.5rem 0;
        }
        
        .metric-label {
            font-size: 0.85rem;
            color: #666;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Mesh Network Routing Visualization</h1>
            <p class="subtitle">Interactive Comparison of Routing Approaches</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul>
                <li><a href="index.html">Overview</a></li>
                <li><a href="#routing" class="active">Routing</a></li>
                <li><a href="technical.html">Technical Details</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="routing">
            <h2>Mesh Network Routing Visualization</h2>
            <p>This interactive visualization demonstrates the different routing approaches used by Meshtastic and MeshCore. Use the controls below to explore how packets are routed through the network.</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--meshtastic-color);"></div>
                    <span>Meshtastic Radio Wave</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--meshcore-color);"></div>
                    <span>MeshCore Radio Wave</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #fd7e14;"></div>
                    <span>Discovery Wave</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #dc3545;"></div>
                    <span>Dropped Signal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #9c27b0;"></div>
                    <span>Route ACK Signal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: rgba(76, 175, 80, 0.1); border: 1px dashed #4caf50;"></div>
                    <span>Node Transmission Range</span>
                </div>
            </div>
            
            <div class="controls">
                <button id="btn-meshtastic" class="control-button meshtastic active">
                    <i class="fas fa-broadcast-tower"></i> Meshtastic Flooding
                </button>
                <button id="btn-meshcore-phase1" class="control-button meshcore">
                    <i class="fas fa-search"></i> MeshCore Path Discovery
                </button>
                <button id="btn-meshcore-phase2" class="control-button meshcore">
                    <i class="fas fa-route"></i> MeshCore Direct Routing
                </button>
                <button id="btn-compare" class="control-button action">
                    <i class="fas fa-balance-scale"></i> Compare Side-by-Side
                </button>
                <button id="btn-reset" class="control-button">
                    <i class="fas fa-redo"></i> Reset
                </button>
            </div>
            
            <div class="network-topology-selector">
                <h4>Network Topology:</h4>
                <div class="topology-buttons">
                    <button id="topology-random" class="topology-button active">
                        <i class="fas fa-random"></i> Random
                    </button>
                    <button id="topology-dense" class="topology-button">
                        <i class="fas fa-th"></i> Dense
                    </button>
                    <button id="topology-sparse" class="topology-button">
                        <i class="fas fa-grip-vertical"></i> Sparse
                    </button>
                    <button id="topology-linear" class="topology-button">
                        <i class="fas fa-ellipsis-h"></i> Linear
                    </button>
                    <button id="topology-star" class="topology-button">
                        <i class="fas fa-asterisk"></i> Star
                    </button>
                </div>
            </div>
            
            <div class="visualization-container" id="network-visualization">
                <!-- D3.js will render the visualization here -->
            </div>
            
            <div class="phase-caption" id="phase-caption">
                Meshtastic Flooding: Radio signals propagate through all nodes within range, which rebroadcast to maximize delivery probability.
            </div>
            
            <div class="performance-metrics">
                <div class="metric-card">
                    <div class="metric-label">Total Packets Sent</div>
                    <div class="metric-value" id="metric-packets">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Network Efficiency</div>
                    <div class="metric-value" id="metric-efficiency">0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Delivery Time</div>
                    <div class="metric-value" id="metric-time">0ms</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Hops Required</div>
                    <div class="metric-value" id="metric-hops">0</div>
                </div>
            </div>
        </section>
        
        <section id="routing-comparison">
            <h2>Routing Methods Compared</h2>
            
            <div class="compare-container">
                <div class="compare-item compare-meshtastic">
                    <h3>Meshtastic Flooding Approach</h3>
                    <ul>
                        <li><strong>High redundancy:</strong> Messages are sent to all nodes within range, which rebroadcast to their neighbors</li>
                        <li><strong>Simple implementation:</strong> No complex routing tables or path discovery needed</li>
                        <li><strong>Higher delivery probability:</strong> Multiple paths increase chances of message delivery</li>
                        <li><strong>Bandwidth intensive:</strong> Network congestion increases with the number of nodes</li>
                        <li><strong>No path optimization:</strong> Uses the same bandwidth regardless of optimal paths</li>
                    </ul>
                </div>
                
                <div class="compare-item compare-meshcore">
                    <h3>MeshCore Selective Routing</h3>
                    <ul>
                        <li><strong>Path discovery phase:</strong> Initial flooding to find optimal route to destination</li>
                        <li><strong>Route establishment:</strong> Creates a persistent path between nodes</li>
                        <li><strong>Bandwidth efficiency:</strong> After path discovery, only nodes on the route forward packets</li>
                        <li><strong>Selective forwarding:</strong> Nodes not on the established route drop packets</li>
                        <li><strong>Adaptable routing:</strong> Routes can be re-established if network topology changes</li>
                    </ul>
                </div>
            </div>
            
            <div class="technical-section">
                <h3>Network Performance Considerations</h3>
                <p>The choice between flooding and selective routing depends on several factors:</p>
                <ul>
                    <li><strong>Network density:</strong> Dense networks benefit more from selective routing to reduce congestion</li>
                    <li><strong>Node reliability:</strong> Unreliable or mobile nodes may benefit from flooding's redundancy</li>
                    <li><strong>Message priority:</strong> MeshCore can prioritize critical messages while Meshtastic treats all messages equally</li>
                    <li><strong>Power consumption:</strong> Selective routing typically requires less overall transmission, saving power across the network</li>
                </ul>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2023 Mesh Networking Comparison. This is for informational purposes only.</p>
            <div class="footer-links">
                <a href="index.html">Overview</a>
                <a href="routing.html">Routing</a>
                <a href="technical.html">Technical Details</a>
            </div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // D3.js visualization code
            const width = document.getElementById('network-visualization').clientWidth;
            const height = document.getElementById('network-visualization').clientHeight;
            
            // Create SVG container
            const svg = d3.select('#network-visualization')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Create a group for the network
            const networkGroup = svg.append('g')
                .attr('class', 'network-group');
            
            // Add tooltip for nodes
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            // Performance metrics tracking variables
            let metrics = {
                packetsSent: 0,
                efficiency: 0,
                deliveryTime: 0,
                hopsRequired: 0
            };
            
            // Topology configurations
            const topologies = {
                random: {
                    name: "Random",
                    description: "Nodes are randomly distributed with varied connectivity",
                    generate: generateRandomTopology
                },
                dense: {
                    name: "Dense",
                    description: "Highly connected network with many redundant paths",
                    generate: generateDenseTopology
                },
                sparse: {
                    name: "Sparse",
                    description: "Limited connectivity with few redundant paths",
                    generate: generateSparseTopology
                },
                linear: {
                    name: "Linear",
                    description: "Nodes form a chain with limited alternative routes",
                    generate: generateLinearTopology
                },
                star: {
                    name: "Star",
                    description: "Central node connects to all others with minimal peripheral connections",
                    generate: generateStarTopology
                }
            };
            
            // Current topology
            let currentTopology = "random";
            
            // Generate network based on selected topology
            let nodes = [];
            let links = [];
            generateNetwork(currentTopology);
            
            // Event listeners for topology buttons
            document.querySelectorAll('.topology-button').forEach(button => {
                button.addEventListener('click', function() {
                    const topologyType = this.id.split('-')[1]; // Extract topology type from button ID
                    
                    // Update active button
                    document.querySelectorAll('.topology-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Generate new network with selected topology
                    currentTopology = topologyType;
                    generateNetwork(topologyType);
                    
                    // Reset any active simulation
                    resetVisualization();
                    
                    // Update caption
                    document.getElementById('phase-caption').innerText = 
                        `Network Topology: ${topologies[topologyType].name} - ${topologies[topologyType].description}`;
                });
            });
            
            // Add event listeners for control buttons
            document.getElementById('btn-meshtastic').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run Meshtastic flooding simulation
                animateMeshtasticFlooding();
            });
            
            document.getElementById('btn-meshcore-phase1').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run MeshCore path discovery simulation
                animateMeshcoreDiscovery();
            });
            
            document.getElementById('btn-meshcore-phase2').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run MeshCore direct routing simulation
                animateMeshcoreDirectRouting();
            });
            
            document.getElementById('btn-compare').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run comparison view
                animateComparison();
            });
            
            document.getElementById('btn-reset').addEventListener('click', function() {
                // Reset visualization
                resetVisualization();
                
                // Reset active button state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById('btn-meshtastic').classList.add('active');
                
                // Reset metrics
                resetMetrics();
                
                // Reset caption
                document.getElementById('phase-caption').innerText = 
                    'Select a routing method to visualize different approaches to mesh networking.';
            });
            
            // Function to generate network based on topology
            function generateNetwork(topologyType) {
                // Clear existing network
                networkGroup.selectAll('*').remove();
                
                // Get topology generator function
                const topologyGenerator = topologies[topologyType].generate;
                
                // Generate nodes and links
                const generatedNetwork = topologyGenerator();
                nodes = generatedNetwork.nodes;
                links = generatedNetwork.links;
                
                // Draw the network
                drawNetwork();
                
                // Reset metrics
                resetMetrics();
            }
            
            // Function to generate random topology
            function generateRandomTopology() {
                // Define nodes with random positions and ranges
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: getRandomRange(320, 480) },
                    { id: 'B', name: 'Node B', type: 'node', range: getRandomRange(240, 400) },
                    { id: 'C', name: 'Node C', type: 'node', range: getRandomRange(280, 440) },
                    { id: 'D', name: 'Node D', type: 'node', range: getRandomRange(200, 360) },
                    { id: 'E', name: 'Node E', type: 'node', range: getRandomRange(320, 480) },
                    { id: 'F', name: 'Node F', type: 'node', range: getRandomRange(280, 400) },
                    { id: 'G', name: 'Node G', type: 'node', range: getRandomRange(240, 360) },
                    { id: 'H', name: 'Node H', type: 'node', range: getRandomRange(280, 440) },
                    { id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: getRandomRange(320, 480) }
                ];
                
                // Assign random positions
                nodes.forEach(node => {
                    const pos = randomPosition();
                    node.x = pos.x;
                    node.y = pos.y;
                });
                
                // Place A and Z at strategic positions
                nodes[0].x = width * 0.15; // A at left side
                nodes[0].y = height * 0.5;
                nodes[8].x = width * 0.85; // Z at right side
                nodes[8].y = height * 0.5;
                
                // Create links based on range
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate dense topology
            function generateDenseTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 600 },
                    { id: 'B', name: 'Node B', type: 'node', range: 560 },
                    { id: 'C', name: 'Node C', type: 'node', range: 560 },
                    { id: 'D', name: 'Node D', type: 'node', range: 560 },
                    { id: 'E', name: 'Node E', type: 'node', range: 560 },
                    { id: 'F', name: 'Node F', type: 'node', range: 560 },
                    { id: 'G', name: 'Node G', type: 'node', range: 560 },
                    { id: 'H', name: 'Node H', type: 'node', range: 560 },
                    { id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 600 }
                ];
                
                // Position in a more evenly distributed pattern
                nodes[0].x = width * 0.15; // A at left side
                nodes[0].y = height * 0.5;
                nodes[1].x = width * 0.3;
                nodes[1].y = height * 0.3;
                nodes[2].x = width * 0.3;
                nodes[2].y = height * 0.7;
                nodes[3].x = width * 0.45;
                nodes[3].y = height * 0.2;
                nodes[4].x = width * 0.45;
                nodes[4].y = height * 0.5;
                nodes[5].x = width * 0.45;
                nodes[5].y = height * 0.8;
                nodes[6].x = width * 0.6;
                nodes[6].y = height * 0.3;
                nodes[7].x = width * 0.6;
                nodes[7].y = height * 0.7;
                nodes[8].x = width * 0.85; // Z at right side
                nodes[8].y = height * 0.5;
                
                // Create links - dense means every node can reach many others
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate sparse topology
            function generateSparseTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 280 },
                    { id: 'B', name: 'Node B', type: 'node', range: 240 },
                    { id: 'C', name: 'Node C', type: 'node', range: 240 },
                    { id: 'D', name: 'Node D', type: 'node', range: 240 },
                    { id: 'E', name: 'Node E', type: 'node', range: 240 },
                    { id: 'F', name: 'Node F', type: 'node', range: 240 },
                    { id: 'G', name: 'Node G', type: 'node', range: 240 },
                    { id: 'H', name: 'Node H', type: 'node', range: 240 },
                    { id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 280 }
                ];
                
                // Position to create sparse network
                nodes[0].x = width * 0.15; // A at left side
                nodes[0].y = height * 0.5;
                nodes[1].x = width * 0.3;
                nodes[1].y = height * 0.3;
                nodes[2].x = width * 0.3;
                nodes[2].y = height * 0.7;
                nodes[3].x = width * 0.45;
                nodes[3].y = height * 0.25;
                nodes[4].x = width * 0.5;
                nodes[4].y = height * 0.5;
                nodes[5].x = width * 0.45;
                nodes[5].y = height * 0.75;
                nodes[6].x = width * 0.65;
                nodes[6].y = height * 0.35;
                nodes[7].x = width * 0.7;
                nodes[7].y = height * 0.65;
                nodes[8].x = width * 0.85; // Z at right side
                nodes[8].y = height * 0.5;
                
                // Create links - much fewer links than dense network
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate linear topology
            function generateLinearTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 240 },
                    { id: 'B', name: 'Node B', type: 'node', range: 240 },
                    { id: 'C', name: 'Node C', type: 'node', range: 240 },
                    { id: 'D', name: 'Node D', type: 'node', range: 240 },
                    { id: 'E', name: 'Node E', type: 'node', range: 240 },
                    { id: 'F', name: 'Node F', type: 'node', range: 240 },
                    { id: 'G', name: 'Node G', type: 'node', range: 240 },
                    { id: 'H', name: 'Node H', type: 'node', range: 240 },
                    { id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 240 }
                ];
                
                // Position in a line
                const step = width * 0.7 / (nodes.length - 1);
                nodes.forEach((node, index) => {
                    node.x = width * 0.15 + (step * index);
                    node.y = height * 0.5 + (Math.random() * 50 - 25); // Slight vertical variation
                });
                
                // Create links only between adjacent nodes
                const links = [];
                for (let i = 0; i < nodes.length - 1; i++) {
                    links.push({
                        source: nodes[i].id,
                        target: nodes[i + 1].id,
                        distance: 1
                    });
                    
                    // Add a few cross links for slightly more complexity
                    if (i < nodes.length - 2 && Math.random() > 0.7) {
                        links.push({
                            source: nodes[i].id,
                            target: nodes[i + 2].id,
                            distance: 2
                        });
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate star topology
            function generateStarTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 800 },
                    { id: 'B', name: 'Node B', type: 'node', range: 240 },
                    { id: 'C', name: 'Node C', type: 'node', range: 240 },
                    { id: 'D', name: 'Node D', type: 'node', range: 240 },
                    { id: 'E', name: 'Node E (Hub)', type: 'node', range: 800 },
                    { id: 'F', name: 'Node F', type: 'node', range: 240 },
                    { id: 'G', name: 'Node G', type: 'node', range: 240 },
                    { id: 'H', name: 'Node H', type: 'node', range: 240 },
                    { id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 240 }
                ];
                
                // Position with E (hub) in the center
                nodes[4].x = width * 0.5; // E at center
                nodes[4].y = height * 0.5;
                
                // Position other nodes around E
                const radius = Math.min(width, height) * 0.35;
                for (let i = 0; i < nodes.length; i++) {
                    if (i !== 4) { // Skip E (hub)
                        const angle = (i * (2 * Math.PI / (nodes.length - 1))) - Math.PI/2;
                        nodes[i].x = nodes[4].x + radius * Math.cos(angle);
                        nodes[i].y = nodes[4].y + radius * Math.sin(angle);
                    }
                }
                
                // Create links - everything connects to the center
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    if (i !== 4) { // Skip E (hub)
                        links.push({
                            source: nodes[4].id, // E (hub)
                            target: nodes[i].id,
                            distance: 1
                        });
                    }
                }
                
                // Add a few peripheral connections
                for (let i = 0; i < 3; i++) {
                    const randomNodeIndex1 = Math.floor(Math.random() * nodes.length);
                    let randomNodeIndex2;
                    do {
                        randomNodeIndex2 = Math.floor(Math.random() * nodes.length);
                    } while (randomNodeIndex1 === randomNodeIndex2 || randomNodeIndex1 === 4 || randomNodeIndex2 === 4);
                    
                    if (isInRange(nodes[randomNodeIndex1], nodes[randomNodeIndex2])) {
                        links.push({
                            source: nodes[randomNodeIndex1].id,
                            target: nodes[randomNodeIndex2].id,
                            distance: 1
                        });
                    }
                }
                
                return { nodes, links };
            }
            
            // Draw the network
            function drawNetwork() {
                // Draw node ranges first so they're in the background
                const nodeRanges = networkGroup.selectAll('.node-range')
                    .data(nodes)
                    .enter()
                    .append('circle')
                    .attr('class', d => `node-range ${d.id === 'A' ? 'meshtastic-range' : d.id === 'Z' ? 'meshcore-range' : ''}`)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', d => d.range)
                    .attr('fill', d => {
                        if (d.type === 'source') return 'rgba(76, 175, 80, 0.1)';
                        if (d.type === 'destination') return 'rgba(233, 30, 99, 0.1)';
                        return 'rgba(200, 200, 200, 0.1)';
                    })
                    .attr('stroke', d => {
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        return '#ccc';
                    });
                
                // Draw links
                const linkElements = networkGroup.selectAll('.network-link')
                    .data(links)
                    .enter()
                    .append('line')
                    .attr('class', 'network-link')
                    .attr('x1', d => nodes.find(n => n.id === d.source).x)
                    .attr('y1', d => nodes.find(n => n.id === d.source).y)
                    .attr('x2', d => nodes.find(n => n.id === d.target).x)
                    .attr('y2', d => nodes.find(n => n.id === d.target).y)
                    .attr('stroke', '#ccc');
                
                // Draw nodes
                const nodeElements = networkGroup.selectAll('.network-node')
                    .data(nodes)
                    .enter()
                    .append('circle')
                    .attr('class', d => `network-node node-${d.id}`)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', 25)
                    .attr('fill', d => {
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        return '#ddd';
                    })
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2)
                    .on('mouseover', function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style('opacity', 0.9);
                        tooltip.html(`${d.name}<br>Range: ${d.range}px`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', function() {
                        tooltip.transition()
                            .duration(500)
                            .style('opacity', 0);
                    });
                
                // Add node labels
                const nodeLabels = networkGroup.selectAll('.node-label')
                    .data(nodes)
                    .enter()
                    .append('text')
                    .attr('class', 'node-label')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y)
                    .text(d => d.id);
            }
            
            // Reset metrics display
            function resetMetrics() {
                metrics = {
                    packetsSent: 0,
                    efficiency: 0,
                    deliveryTime: 0,
                    hopsRequired: 0
                };
                
                // Update display
                document.getElementById('metric-packets').textContent = '0';
                document.getElementById('metric-efficiency').textContent = '0%';
                document.getElementById('metric-time').textContent = '0ms';
                document.getElementById('metric-hops').textContent = '0';
            }
            
            // Update metrics
            function updateMetrics(data) {
                // Update metrics object
                Object.assign(metrics, data);
                
                // Update display
                if ('packetsSent' in data) {
                    document.getElementById('metric-packets').textContent = metrics.packetsSent;
                }
                if ('efficiency' in data) {
                    document.getElementById('metric-efficiency').textContent = `${Math.round(metrics.efficiency * 100)}%`;
                }
                if ('deliveryTime' in data) {
                    document.getElementById('metric-time').textContent = `${metrics.deliveryTime}ms`;
                }
                if ('hopsRequired' in data) {
                    document.getElementById('metric-hops').textContent = metrics.hopsRequired;
                }
            }
            
            // Ensure these existing functions take metrics into account
            
            // Utility functions
            function randomPosition(paddingPercent = 0.1) {
                const padding = Math.min(width, height) * paddingPercent;
                return {
                    x: Math.random() * (width - 2 * padding) + padding,
                    y: Math.random() * (height - 2 * padding) + padding
                };
            }
            
            function getRandomRange(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            
            function isInRange(nodeA, nodeB) {
                const dx = nodeA.x - nodeB.x;
                const dy = nodeA.y - nodeB.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                // Nodes are connected if either one's range reaches the other
                return distance <= nodeA.range || distance <= nodeB.range;
            }
            
            // Animation functions
            function createPacket(sourceNode, targetNode, packetClass) {
                const packet = networkGroup.append('circle')
                    .attr('class', `packet ${packetClass}`)
                    .attr('cx', sourceNode.x)
                    .attr('cy', sourceNode.y)
                    .attr('r', 8)
                    .attr('fill-opacity', 0.8);
                
                return packet;
            }
            
            function animatePacket(packet, sourceNode, targetNode, duration, delay, callback) {
                // Create expanding ring effect
                const packetType = packet.attr('class').includes('meshtastic') ? 'meshtastic-ring' :
                                 packet.attr('class').includes('discovery') ? 'discovery-ring' : 
                                 packet.attr('class').includes('meshcore') ? 'meshcore-ring' : 'dropped-ring';
                
                const ring = networkGroup.append('circle')
                    .attr('class', `packet-ring ${packetType}`)
                    .attr('cx', sourceNode.x)
                    .attr('cy', sourceNode.y)
                    .attr('r', 10)
                    .attr('stroke-opacity', 0.8)
                    .attr('stroke-width', 2);
                
                // Animate the expanding ring
                ring.transition()
                    .duration(duration)
                    .attr('r', sourceNode.range)
                    .attr('stroke-opacity', 0)
                    .remove();
                
                // Animate the packet
                packet.transition()
                    .delay(delay)
                    .duration(duration)
                    .attr('cx', targetNode.x)
                    .attr('cy', targetNode.y)
                    .on('end', callback);
                
                return packet;
            }
            
            function createFloodWave(sourceNode, waveClass) {
                const wave = networkGroup.append('circle')
                    .attr('class', `flood-wave ${waveClass}`)
                    .attr('cx', sourceNode.x)
                    .attr('cy', sourceNode.y)
                    .attr('r', 10)
                    .attr('stroke-opacity', 0.8);
                
                // Animate the wave
                wave.transition()
                    .duration(2000)
                    .attr('r', sourceNode.range)
                    .attr('stroke-opacity', 0)
                    .remove();
            }
            
            function highlightOptimalPath() {
                // Find optimal path
                const path = findOptimalPath();
                
                if (path.length < 2) {
                    console.warn("No valid path found to highlight");
                    return;
                }
                
                // Highlight links along the path
                for (let i = 0; i < path.length - 1; i++) {
                    networkGroup.selectAll('.network-link')
                        .filter(d => 
                            (d.source === path[i] && d.target === path[i + 1]) || 
                            (d.target === path[i] && d.source === path[i + 1]))
                        .transition()
                        .duration(500)
                        .attr('stroke', '#43a047') // Meshcore color
                        .attr('stroke-width', 4)
                        .attr('stroke-opacity', 1);
                }
                
                // Highlight nodes along the path
                networkGroup.selectAll('.network-node')
                    .filter(d => path.includes(d.id) && d.id !== 'A' && d.id !== 'Z')
                    .transition()
                    .duration(500)
                    .attr('fill', '#43a047'); // Meshcore color
            }
            
            // Find optimal path based on distance and connections
            function findOptimalPath() {
                // Simple breadth-first search to find a path
                const queue = [{ id: 'A', path: ['A'] }];
                const visited = new Set(['A']);
                
                while (queue.length > 0) {
                    const { id, path } = queue.shift();
                    
                    // If we reached Z, return the path
                    if (id === 'Z') {
                        return path;
                    }
                    
                    // Find all connected nodes
                    const connectedLinks = links.filter(link => 
                        (link.source === id || link.target === id));
                    
                    for (const link of connectedLinks) {
                        const nextId = link.source === id ? link.target : link.source;
                        if (!visited.has(nextId)) {
                            visited.add(nextId);
                            queue.push({ id: nextId, path: [...path, nextId] });
                        }
                    }
                }
                
                // If no path found, return a default path or empty array
                console.warn("No path found between A and Z");
                return [];
            }
            
            // Find optimal path dynamically based on network topology
            const optimalPath = findOptimalPath();
            
            function animateMeshcoreDiscovery() {
                // Reset visualization
                resetVisualization();
                
                // Reset metrics
                resetMetrics();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'MeshCore Path Discovery: Initial radio wave propagation to find the optimal path to the destination.';
                
                // Find nodes by ID
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                // Start timing for delivery time metric
                const startTime = Date.now();
                let totalPackets = 0;
                let hasReachedDestination = false;
                
                // Create a flood wave from source node
                createFloodWave(nodes[0], 'meshcore-wave');
                
                // Get all links from A (first wave)
                const aLinks = links.filter(link => link.source === 'A' || link.target === 'A')
                    .map(link => {
                        const targetId = link.source === 'A' ? link.target : link.source;
                        return { sourceId: 'A', targetId };
                    });
                
                // First wave: from A to all connected nodes
                const firstWavePackets = aLinks.map(link => {
                    const packet = createPacket(nodeMap['A'], nodeMap[link.targetId], 'packet-discovery');
                    
                    // Increment packet count
                    totalPackets++;
                    updateMetrics({ packetsSent: totalPackets });
                    
                    return { packet, link };
                });
                
                // Animate first wave
                firstWavePackets.forEach(({ packet, link }, index) => {
                    animatePacket(packet, nodeMap['A'], nodeMap[link.targetId], 500, 500, function() {
                        // If this is the last packet, continue with the second wave
                        if (index === firstWavePackets.length - 1) {
                            animateSecondWave();
                        }
                    });
                });
                
                function animateSecondWave() {
                    // Get second wave links (from all nodes except A and Z)
                    const secondWaveLinks = [];
                    firstWavePackets.forEach(({ link }) => {
                        if (link.targetId !== 'Z') { // Skip if we already reached Z
                            const nodeLinks = links.filter(l => 
                                (l.source === link.targetId || l.target === link.targetId) && 
                                l.source !== 'A' && l.target !== 'A');
                            
                            nodeLinks.forEach(nodeLink => {
                                const targetId = nodeLink.source === link.targetId ? nodeLink.target : nodeLink.source;
                                // Don't go backwards
                                if (targetId !== 'A') {
                                    secondWaveLinks.push({ sourceId: link.targetId, targetId });
                                }
                            });
                        }
                    });
                    
                    // Create and animate second wave packets
                    const secondWavePackets = secondWaveLinks.map(link => {
                        const packet = createPacket(nodeMap[link.sourceId], nodeMap[link.targetId], 'packet-discovery');
                        
                        // Increment packet count
                        totalPackets++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        return { packet, link };
                    });
                    
                    secondWavePackets.forEach(({ packet, link }, index) => {
                        animatePacket(packet, nodeMap[link.sourceId], nodeMap[link.targetId], 500, 500, function() {
                            // If this is the last packet, continue with the third wave
                            if (index === secondWavePackets.length - 1) {
                                // Continue with a third wave to show ongoing flooding
                                setTimeout(function() {
                                    animateThirdWave(secondWaveLinks);
                                }, 500);
                            }
                            
                            // If this packet reached Z, mark it but don't stop the simulation
                            if (link.targetId === 'Z' && !hasReachedDestination) {
                                hasReachedDestination = true;
                                
                                // Flash destination node to indicate receipt
                                networkGroup.selectAll('.network-node')
                                    .filter(d => d.id === 'Z')
                                    .transition()
                                    .duration(300)
                                    .attr('r', 35)
                                    .transition()
                                    .duration(300)
                                    .attr('r', 25);
                                    
                                // Update caption to indicate destination reached but flooding continues
                                document.getElementById('phase-caption').innerText = 
                                    'MeshCore Path Discovery: Destination reached, but flooding continues throughout the network.';
                            }
                        });
                    });
                }
                
                function animateThirdWave(previousLinks) {
                    // Track visited links to avoid duplicates
                    const visitedLinkKeys = new Set();
                    previousLinks.forEach(link => {
                        visitedLinkKeys.add(`${link.sourceId}-${link.targetId}`);
                        visitedLinkKeys.add(`${link.targetId}-${link.sourceId}`);
                    });
                    
                    // Get third wave links
                    const thirdWaveLinks = [];
                    previousLinks.forEach(prevLink => {
                        // Skip if source is Z (destination reached)
                        if (prevLink.targetId !== 'Z') { 
                            const nodeLinks = links.filter(l => 
                                (l.source === prevLink.targetId || l.target === prevLink.targetId) && 
                                l.source !== prevLink.sourceId && l.target !== prevLink.sourceId);
                            
                            nodeLinks.forEach(nodeLink => {
                                const targetId = nodeLink.source === prevLink.targetId ? nodeLink.target : nodeLink.source;
                                // Avoid creating duplicate links
                                const linkKey = `${prevLink.targetId}-${targetId}`;
                                const reverseLinkKey = `${targetId}-${prevLink.targetId}`;
                                
                                if (!visitedLinkKeys.has(linkKey) && !visitedLinkKeys.has(reverseLinkKey)) {
                                    visitedLinkKeys.add(linkKey);
                                    visitedLinkKeys.add(reverseLinkKey);
                                    thirdWaveLinks.push({ sourceId: prevLink.targetId, targetId });
                                }
                            });
                        }
                    });
                    
                    // If no more links to traverse, finish the flooding phase
                    if (thirdWaveLinks.length === 0) {
                        finishFloodingPhase();
                        return;
                    }
                    
                    // Create and animate third wave packets
                    const thirdWavePackets = thirdWaveLinks.map(link => {
                        const packet = createPacket(nodeMap[link.sourceId], nodeMap[link.targetId], 'packet-discovery');
                        
                        // Increment packet count
                        totalPackets++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        return { packet, link };
                    });
                    
                    thirdWavePackets.forEach(({ packet, link }, index) => {
                        animatePacket(packet, nodeMap[link.sourceId], nodeMap[link.targetId], 500, 500, function() {
                            // If this is the last packet, finish flooding phase
                            if (index === thirdWavePackets.length - 1) {
                                finishFloodingPhase();
                            }
                            
                            // If this packet reached Z and we haven't marked it yet
                            if (link.targetId === 'Z' && !hasReachedDestination) {
                                hasReachedDestination = true;
                                
                                // Flash destination node to indicate receipt
                                networkGroup.selectAll('.network-node')
                                    .filter(d => d.id === 'Z')
                                    .transition()
                                    .duration(300)
                                    .attr('r', 35)
                                    .transition()
                                    .duration(300)
                                    .attr('r', 25);
                                    
                                // Update caption to indicate destination reached but flooding continues
                                document.getElementById('phase-caption').innerText = 
                                    'MeshCore Path Discovery: Destination reached, but flooding continues throughout the network.';
                            }
                        });
                    });
                }
                
                function finishFloodingPhase() {
                    setTimeout(function() {
                        // Calculate discovery phase metrics
                        const discoveryTime = Date.now() - startTime;
                        
                        // Update metrics for discovery phase
                        updateMetrics({
                            deliveryTime: discoveryTime
                        });
                        
                        // Find the optimal path
                        const optimalPath = findOptimalPath();
                        
                        // Update caption to show ACK phase
                        document.getElementById('phase-caption').innerText = 
                            'MeshCore Path Discovery: Flooding complete. Sending ACK with optimal path information back to source.';
                        
                        // Highlight the optimal path
                        highlightOptimalPath();
                        
                        // Send ACK packets back along the optimal path from Z to A
                        if (optimalPath.length >= 2) {
                            // Create a slight delay before starting ACK process
                            setTimeout(function() {
                                animatePathAck(optimalPath);
                            }, 1000);
                        } else {
                            // No valid path found
                            document.getElementById('phase-caption').innerText = 
                                'No valid path found between source and destination.';
                        }
                    }, 1000);
                }
                
                // Function to animate acknowledgment packets returning along the optimal path
                function animatePathAck(path) {
                    // Reverse the path to go from Z to A
                    const reversePath = [...path].reverse();
                    
                    // Create and animate ACK packets along the path
                    animateAckSegment(0);
                    
                    function animateAckSegment(currentIndex) {
                        if (currentIndex >= reversePath.length - 1) {
                            // We've reached the source node, route is established
                            
                            // Highlight source node to indicate receipt of ACK
                            networkGroup.selectAll('.network-node')
                                .filter(d => d.id === 'A')
                                .transition()
                                .duration(300)
                                .attr('r', 30)
                                .transition()
                                .duration(300)
                                .attr('r', 25);
                            
                            // Update caption
                            document.getElementById('phase-caption').innerText = 
                                'MeshCore Path Discovery: Route established! The source now knows the optimal path to the destination.';
                            
                            return;
                        }
                        
                        // Get current segment nodes
                        const sourceId = reversePath[currentIndex];
                        const targetId = reversePath[currentIndex + 1];
                        
                        // Create ACK packet with special styling
                        const ackPacket = networkGroup.append('circle')
                            .attr('class', 'packet packet-ack')
                            .attr('cx', nodeMap[sourceId].x)
                            .attr('cy', nodeMap[sourceId].y)
                            .attr('r', 8)
                            .attr('fill', '#9c27b0') // Purple color for ACK packets
                            .attr('fill-opacity', 0.8)
                            .attr('stroke', '#fff')
                            .attr('stroke-width', 2);
                        
                        // Add a special ring effect for ACK
                        const ring = networkGroup.append('circle')
                            .attr('class', 'packet-ring ack-ring')
                            .attr('cx', nodeMap[sourceId].x)
                            .attr('cy', nodeMap[sourceId].y)
                            .attr('r', 10)
                            .attr('stroke', '#9c27b0')
                            .attr('stroke-opacity', 0.8)
                            .attr('stroke-width', 2)
                            .attr('fill', 'none');
                        
                        // Animate the ring
                        ring.transition()
                            .duration(500)
                            .attr('r', nodeMap[sourceId].range * 0.5)
                            .attr('stroke-opacity', 0)
                            .remove();
                        
                        // Increment packet count for the ACK
                        totalPackets++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        // Animate the ACK packet
                        ackPacket.transition()
                            .duration(600)
                            .attr('cx', nodeMap[targetId].x)
                            .attr('cy', nodeMap[targetId].y)
                            .on('end', function() {
                                // Flash the receiving node to indicate receipt
                                networkGroup.selectAll('.network-node')
                                    .filter(d => d.id === targetId)
                                    .transition()
                                    .duration(200)
                                    .attr('r', 28)
                                    .transition()
                                    .duration(200)
                                    .attr('r', 25);
                                
                                // Remove the ACK packet
                                d3.select(this).remove();
                                
                                // Continue to next segment
                                setTimeout(function() {
                                    animateAckSegment(currentIndex + 1);
                                }, 400);
                            });
                    }
                }
            }
            
            function animateMeshcoreDirectRouting() {
                // Reset visualization but keep optimal path highlighted
                resetVisualization(false);
                
                // Reset metrics but keep discovery metrics (if any)
                const discoveryTime = metrics.deliveryTime;
                const discoveryPackets = metrics.packetsSent;
                resetMetrics();
                updateMetrics({ 
                    packetsSent: discoveryPackets || 0,
                    deliveryTime: discoveryTime || 0
                });
                
                // Make sure optimal path is highlighted
                highlightOptimalPath();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'MeshCore Direct Routing: After discovery, radio signals follow only the established optimal path. Nodes not on the path drop signals.';
                
                // Find nodes by ID
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                // Start timing for direct routing phase
                const startTime = Date.now();
                let directPackets = 0;
                let hasReachedDestination = false;
                
                // Animate direct route along optimal path
                if (optimalPath.length >= 2) {
                    animateDirectPath(0);
                } else {
                    document.getElementById('phase-caption').innerText = 
                        'No valid path found between source and destination. Try refreshing to generate a new network.';
                }
                
                function animateDirectPath(currentIndex) {
                    if (currentIndex >= optimalPath.length - 1) {
                        // We've reached the destination
                        if (!hasReachedDestination) {
                            hasReachedDestination = true;
                            
                            // Calculate direct routing metrics
                            const directTime = Date.now() - startTime;
                            const totalTime = directTime + (discoveryTime || 0);
                            const hopsRequired = optimalPath.length - 1;
                            const totalPackets = (discoveryPackets || 0) + directPackets;
                            
                            // Calculate efficiency ratio (optimal path / total packets)
                            const efficiency = hopsRequired / totalPackets;
                            
                            // Update metrics
                            updateMetrics({
                                packetsSent: totalPackets,
                                deliveryTime: totalTime,
                                hopsRequired: hopsRequired,
                                efficiency: efficiency
                            });
                        }
                        
                        // Show a success effect
                        nodeElements.filter(d => d.id === 'Z')
                            .transition()
                            .duration(300)
                            .attr('fill', '#4caf50')
                            .transition()
                            .duration(300)
                            .attr('fill', '#e91e63');
                        
                        // After a delay, show a dropped packet for demonstration
                        setTimeout(function() {
                            // Find a node that's not on the path but connected to A
                            const offPathLinks = links.filter(link => 
                                (link.source === 'A' || link.target === 'A') && 
                                !optimalPath.includes(link.source === 'A' ? link.target : link.source));
                            
                            if (offPathLinks.length > 0) {
                                const randomLink = offPathLinks[Math.floor(Math.random() * offPathLinks.length)];
                                const targetId = randomLink.source === 'A' ? randomLink.target : randomLink.source;
                                
                                // Create and animate a dropped packet
                                const droppedPacket = createPacket(nodeMap['A'], nodeMap[targetId], 'packet-dropped');
                                
                                // Increment packet count
                                directPackets++;
                                updateMetrics({ packetsSent: (discoveryPackets || 0) + directPackets });
                                
                                animatePacket(droppedPacket, nodeMap['A'], nodeMap[targetId], 500, 200, function() {
                                    // Show packet being dropped
                                    d3.select(this)
                                        .transition()
                                        .duration(200)
                                        .attr('r', 0)
                                        .attr('fill-opacity', 0);
                                    
                                    // Show another successful direct route after a delay
                                    setTimeout(function() {
                                        animateDirectPath(0); // Repeat the animation
                                    }, 1000);
                                });
                            } else {
                                // No eligible off-path links, just repeat the direct path
                                setTimeout(function() {
                                    animateDirectPath(0);
                                }, 1000);
                            }
                        }, 1000);
                        
                        return;
                    }
                    
                    // Create and animate packet along the current segment of the path
                    const sourceId = optimalPath[currentIndex];
                    const targetId = optimalPath[currentIndex + 1];
                    
                    const packet = createPacket(nodeMap[sourceId], nodeMap[targetId], 'packet-meshcore');
                    
                    // Increment packet count
                    directPackets++;
                    updateMetrics({ packetsSent: (discoveryPackets || 0) + directPackets });
                    
                    animatePacket(packet, nodeMap[sourceId], nodeMap[targetId], 500, 500, function() {
                        // Continue to the next segment
                        animateDirectPath(currentIndex + 1);
                    });
                }
            }
            
            function animateMeshtasticFlooding() {
                // Reset visualization
                resetVisualization();
                
                // Reset metrics
                resetMetrics();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'Meshtastic Flooding: Radio signals propagate through all nodes within range, which rebroadcast to maximize delivery probability.';
                
                // Find nodes by ID
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                // Set to track visited nodes to avoid loops
                const visited = new Set(['A']);
                const rebroadcastQueue = [];
                
                // Start timing for delivery time metric
                const startTime = Date.now();
                let hasReachedDestination = false;
                let totalPackets = 0;
                
                // Start flood from node A with visible waves
                floodFromNode('A', visited, 0);
                
                function floodFromNode(nodeId, visited, depth) {
                    if (depth > 5) return; // Limit recursion depth
                    
                    const sourceNode = nodes.find(n => n.id === nodeId);
                    
                    // Create a visible flood wave from this node
                    createFloodWave(sourceNode, 'meshtastic-wave');
                    
                    // Get all connections for this node
                    const nodeLinks = links.filter(link => 
                        link.source === nodeId || link.target === nodeId);
                    
                    // Create a packet for each connection
                    nodeLinks.forEach((link, index) => {
                        const targetId = link.source === nodeId ? link.target : link.source;
                        
                        // Skip if we've already visited this node from this origin
                        if (visited.has(targetId + '-from-' + nodeId)) return;
                        visited.add(targetId + '-from-' + nodeId);
                        
                        // Create and animate packet with enhanced rings
                        const packet = createPacket(nodeMap[nodeId], nodeMap[targetId], 'packet-meshtastic');
                        
                        // Increment packet count
                        totalPackets++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        animatePacket(packet, nodeMap[nodeId], nodeMap[targetId], 800, 300 + (index * 200), function() {
                            // Schedule the next wave with a slight delay
                            rebroadcastQueue.push({
                                nodeId: targetId,
                                delay: 800
                            });
                            
                            // If this is the last link, process the queue
                            if (index === nodeLinks.length - 1) {
                                processRebroadcastQueue();
                            }
                            
                            // If we reached Z, show success effect and update metrics
                            if (targetId === 'Z' && !hasReachedDestination) {
                                hasReachedDestination = true;
                                
                                // Calculate delivery time
                                const deliveryTime = Date.now() - startTime;
                                
                                // Calculate hop count (by depth)
                                const hopsRequired = depth + 1;
                                
                                // Calculate efficiency (optimal path / total packets)
                                // A lower ratio means more network congestion
                                const optimalPath = findOptimalPath();
                                const efficiency = optimalPath.length > 0 ? 
                                    (optimalPath.length - 1) / totalPackets : 0;
                                
                                // Update metrics
                                updateMetrics({
                                    deliveryTime: deliveryTime,
                                    hopsRequired: hopsRequired,
                                    efficiency: efficiency
                                });
                                
                                nodeElements.filter(d => d.id === 'Z')
                                    .transition()
                                    .duration(300)
                                    .attr('fill', '#4caf50')
                                    .transition()
                                    .duration(300)
                                    .attr('fill', '#e91e63');
                            }
                        });
                    });
                }
                
                function processRebroadcastQueue() {
                    if (rebroadcastQueue.length === 0) return;
                    
                    const nextBroadcast = rebroadcastQueue.shift();
                    setTimeout(function() {
                        floodFromNode(nextBroadcast.nodeId, visited, 1);
                        processRebroadcastQueue();
                    }, nextBroadcast.delay);
                }
            }
            
            function resetVisualization(clearOptimalPath = true) {
                // Remove all packets
                networkGroup.selectAll('.packet, .packet-ring, .flood-wave').remove();
                
                // Clear any existing animations
                d3.selectAll('.packet').interrupt();
                d3.selectAll('.network-node').interrupt();
                
                // Reset node colors
                networkGroup.selectAll('.network-node')
                    .transition()
                    .duration(300)
                    .attr('fill', d => {
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        return '#ddd';
                    })
                    .attr('r', 25);
                
                // Clear optimal path highlighting if requested
                if (clearOptimalPath) {
                    networkGroup.selectAll('.network-link')
                        .transition()
                        .duration(300)
                        .attr('stroke', '#ccc')
                        .attr('stroke-width', 2)
                        .attr('stroke-opacity', 0.6);
                }
            }
            
            function animateComparison() {
                // Reset visualization
                resetVisualization();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'Side-by-Side Comparison: Meshtastic flooding (left) vs MeshCore selective routing (right)';
                
                // Split the visualization into two parts
                const splitWidth = width / 2;
                
                // Create comparison container
                const comparisonContainer = d3.select('#network-visualization')
                    .append('div')
                    .attr('class', 'comparison-container')
                    .style('display', 'flex')
                    .style('width', '100%')
                    .style('height', '100%');
                
                // Create left view (Meshtastic)
                const leftView = comparisonContainer
                    .append('div')
                    .attr('class', 'comparison-view left-view')
                    .style('width', '50%')
                    .style('height', '100%')
                    .style('position', 'relative')
                    .style('border-right', '1px dashed #ccc');
                
                // Create right view (MeshCore)
                const rightView = comparisonContainer
                    .append('div')
                    .attr('class', 'comparison-view right-view')
                    .style('width', '50%')
                    .style('height', '100%')
                    .style('position', 'relative');
                
                // Create SVG for left view
                const leftSvg = leftView
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%');
                
                // Create SVG for right view
                const rightSvg = rightView
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%');
                
                // Add labels
                leftView.append('div')
                    .attr('class', 'view-label')
                    .style('position', 'absolute')
                    .style('top', '10px')
                    .style('left', '10px')
                    .style('background-color', 'rgba(30, 136, 229, 0.9)')
                    .style('color', 'white')
                    .style('padding', '5px 10px')
                    .style('border-radius', '4px')
                    .style('font-weight', 'bold')
                    .text('Meshtastic Flooding');
                
                rightView.append('div')
                    .attr('class', 'view-label')
                    .style('position', 'absolute')
                    .style('top', '10px')
                    .style('left', '10px')
                    .style('background-color', 'rgba(67, 160, 71, 0.9)')
                    .style('color', 'white')
                    .style('padding', '5px 10px')
                    .style('border-radius', '4px')
                    .style('font-weight', 'bold')
                    .text('MeshCore Selective Routing');
                
                // Add metrics displays
                const leftMetrics = leftView.append('div')
                    .attr('class', 'view-metrics')
                    .style('position', 'absolute')
                    .style('bottom', '10px')
                    .style('left', '10px')
                    .style('right', '10px')
                    .style('background-color', 'rgba(255, 255, 255, 0.9)')
                    .style('padding', '5px')
                    .style('border-radius', '4px')
                    .style('font-size', '0.9em');
                
                const rightMetrics = rightView.append('div')
                    .attr('class', 'view-metrics')
                    .style('position', 'absolute')
                    .style('bottom', '10px')
                    .style('left', '10px')
                    .style('right', '10px')
                    .style('background-color', 'rgba(255, 255, 255, 0.9)')
                    .style('padding', '5px')
                    .style('border-radius', '4px')
                    .style('font-size', '0.9em');
                
                leftMetrics.html('<b>Packets:</b> <span id="left-packets">0</span> | <b>Efficiency:</b> <span id="left-efficiency">0%</span> | <b>Time:</b> <span id="left-time">0ms</span>');
                rightMetrics.html('<b>Packets:</b> <span id="right-packets">0</span> | <b>Efficiency:</b> <span id="right-efficiency">0%</span> | <b>Time:</b> <span id="right-time">0ms</span>');
                
                // Hide main SVG
                svg.style('display', 'none');
                
                // Add start button
                const startButton = d3.select('#network-visualization')
                    .append('button')
                    .attr('class', 'start-comparison-button')
                    .style('position', 'absolute')
                    .style('top', '50%')
                    .style('left', '50%')
                    .style('transform', 'translate(-50%, -50%)')
                    .style('z-index', '100')
                    .style('padding', '10px 20px')
                    .style('background-color', '#e74c3c')
                    .style('color', 'white')
                    .style('border', 'none')
                    .style('border-radius', '5px')
                    .style('font-weight', 'bold')
                    .style('cursor', 'pointer')
                    .text('Start Comparison');
                
                // Add exit button
                const exitButton = d3.select('#network-visualization')
                    .append('button')
                    .attr('class', 'exit-comparison-button')
                    .style('position', 'absolute')
                    .style('top', '10px')
                    .style('right', '10px')
                    .style('z-index', '100')
                    .style('padding', '5px 10px')
                    .style('background-color', '#6c757d')
                    .style('color', 'white')
                    .style('border', 'none')
                    .style('border-radius', '5px')
                    .style('font-weight', 'bold')
                    .style('cursor', 'pointer')
                    .text('Exit Comparison')
                    .on('click', exitComparisonView);
                
                startButton.on('click', function() {
                    // Hide the button
                    d3.select(this).style('display', 'none');
                    
                    // Run animations simultaneously
                    setTimeout(() => {
                        // This is a simplified version showing the concept
                        alert('For a full comparison, please run the individual animations. The side-by-side comparison requires significant refactoring of the visualization code.');
                        
                        // For a proper implementation, you would need to:
                        // 1. Clone the network generation code to create two separate networks
                        // 2. Refactor the animation functions to take an SVG container as parameter
                        // 3. Run the animations in parallel on both networks
                    }, 100);
                });
            }
            
            function exitComparisonView() {
                // Remove comparison elements
                d3.select('.comparison-container').remove();
                d3.select('.start-comparison-button').remove();
                d3.select('.exit-comparison-button').remove();
                
                // Show main SVG again
                svg.style('display', 'block');
                
                // Reset the visualization
                resetVisualization();
                
                // Reset active button state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById('btn-meshtastic').classList.add('active');
                
                // Reset caption
                document.getElementById('phase-caption').innerText = 
                    'Select a routing method to visualize different approaches to mesh networking.';
                
                // Reset metrics
                resetMetrics();
            }
            
            // Start with Meshtastic flooding by default
            setTimeout(animateMeshtasticFlooding, 500);
        });
        
        // Add smooth scrolling and other UI functionality
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    window.scrollTo({
                        top: target.offsetTop - 70,
                        behavior: 'smooth'
                    });
                }
            });
        });
    </script>
</body>
</html> 