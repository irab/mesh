<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mesh Network Routing Visualization</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        /* Specific styles for the D3 visualization */
        .visualization-container {
            margin: 2rem auto;
            width: 100%;
            max-width: 1000px;
            height: 500px;
            border-radius: var(--border-radius);
            background-color: #f8f9fa;
            box-shadow: var(--card-shadow);
            position: relative;
            overflow: hidden;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin: 1rem 0 2rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .control-button {
            padding: 8px 16px;
            background-color: #f8f9fa;
            border: 2px solid #ddd;
            border-radius: 20px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .control-button:hover {
            border-color: #aaa;
            transform: translateY(-2px);
        }
        
        .control-button.meshtastic {
            border-color: var(--meshtastic-color);
        }
        
        .control-button.meshtastic.active {
            background-color: var(--meshtastic-color);
            color: white;
        }
        
        .control-button.meshcore {
            border-color: var(--meshcore-color);
        }
        
        .control-button.meshcore.active {
            background-color: var(--meshcore-color);
            color: white;
        }
        
        .control-button.action {
            border-color: var(--accent-color);
        }
        
        .control-button.action.active {
            background-color: var(--accent-color);
            color: white;
        }
        
        .phase-caption {
            text-align: center;
            padding: 1rem;
            margin-top: 1rem;
            background-color: rgba(255, 255, 255, 0.8);
            border-radius: var(--border-radius);
            max-width: 600px;
            margin: 0 auto;
            font-weight: 500;
            border-left: 4px solid var(--accent-color);
        }
        
        .network-node {
            cursor: pointer;
        }
        
        .node-label {
            font-weight: bold;
            text-anchor: middle;
            dominant-baseline: central;
            pointer-events: none;
        }
        
        .network-link {
            stroke-width: 2;
            stroke-opacity: 0.6;
        }
        
        .packet {
            fill-opacity: 0.8;
        }
        
        .packet-meshtastic {
            fill: var(--meshtastic-color);
        }
        
        .packet-meshcore {
            fill: var(--meshcore-color);
        }
        
        .packet-discovery {
            fill: #fd7e14;
        }
        
        .packet-dropped {
            fill: #dc3545;
        }
        
        .packet-ack {
            fill: #9c27b0;  /* Purple color for ACK packets */
            stroke: #fff;
            stroke-width: 2;
        }
        
        /* Expanding ring styles */
        .packet-ring {
            fill: none;
            stroke-width: 2;
            pointer-events: none;
        }
        
        .packet-ring.meshtastic-ring {
            stroke: var(--meshtastic-color);
        }
        
        .packet-ring.meshcore-ring {
            stroke: var(--meshcore-color);
        }
        
        .packet-ring.discovery-ring {
            stroke: #fd7e14;
        }
        
        .packet-ring.dropped-ring {
            stroke: #dc3545;
        }
        
        .packet-ring.ack-ring {
            stroke: #9c27b0;  /* Purple color for ACK rings */
            stroke-dasharray: 3,3;  /* Dashed stroke for ACK rings */
        }
        
        /* Flood wave animation */
        .flood-wave {
            fill: none;
            stroke-width: 3;
            pointer-events: none;
        }
        
        .flood-wave.meshtastic-wave {
            stroke: var(--meshtastic-color);
        }
        
        .flood-wave.meshcore-wave {
            stroke: var(--meshcore-color);
        }
        
        .node-range {
            fill-opacity: 0.1;
            stroke-opacity: 0.3;
            stroke-width: 1;
            stroke-dasharray: 5,5;
            pointer-events: none;
            transition: fill 0.3s, stroke 0.3s, fill-opacity 0.3s, stroke-opacity 0.3s;
        }
        
        .meshtastic-range {
            fill: var(--meshtastic-color);
            stroke: var(--meshtastic-color);
        }
        
        .meshcore-range {
            fill: var(--meshcore-color);
            stroke: var(--meshcore-color);
        }
        
        /* New styles for broadcast states */
        .node-range.has-broadcast {
            fill-opacity: 0.2;
            stroke-opacity: 0.5;
            stroke-width: 2;
        }
        
        .node-range.has-sent-ack {
            stroke: rgba(156, 39, 176, 0.4); /* Purple with transparency */
            fill-opacity: 0.2;
            stroke-opacity: 0.5;
            stroke-width: 2;
        }
        
        /* New styles for received message states */
        .node-range.has-received-message {
            fill: rgba(76, 175, 80, 0.2); /* Green with transparency */
            fill-opacity: 0.25;
        }
        
        .node-range.has-received-ack {
            fill: rgba(156, 39, 176, 0.2); /* Purple with transparency */
            fill-opacity: 0.25;
        }
        
        .tooltip {
            position: absolute;
            padding: 10px;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 5px;
            pointer-events: none;
            font-size: 14px;
            z-index: 100;
            transition: opacity 0.3s;
        }
        
        .compare-container {
            display: flex;
            flex-wrap: wrap;
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .compare-item {
            flex: 1 1 calc(50% - 1rem);
            min-width: 280px;
            background-color: #fff;
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
            padding: 1.5rem;
        }
        
        .compare-item h3 {
            margin-top: 0;
            border-bottom: 2px solid var(--accent-color);
            padding-bottom: 0.5rem;
            text-align: center;
        }
        
        .compare-meshtastic h3 {
            border-color: var(--meshtastic-color);
            color: var(--meshtastic-color);
        }
        
        .compare-meshcore h3 {
            border-color: var(--meshcore-color);
            color: var(--meshcore-color);
        }
        
        .legend {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 1rem 0;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.9rem;
        }
        
        .legend-color {
            width: 15px;
            height: 15px;
            border-radius: 50%;
        }
        
        /* Network Topology Selector Styles */
        .network-topology-selector {
            margin: 1.5rem 0;
            text-align: center;
            background-color: #fff;
            padding: 1rem;
            border-radius: var(--border-radius);
            box-shadow: var(--card-shadow);
        }
        
        .network-topology-selector h4 {
            margin: 0 0 0.5rem 0;
            color: var(--header-bg-color);
        }
        
        .topology-buttons {
            display: flex;
            justify-content: center;
            gap: 0.75rem;
            flex-wrap: wrap;
        }
        
        .topology-button {
            padding: 0.5rem 1rem;
            background-color: #f8f9fa;
            border: 1px solid #ddd;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 500;
            font-size: 0.9rem;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .topology-button:hover {
            background-color: #e9ecef;
            transform: translateY(-2px);
        }
        
        .topology-button.active {
            background-color: var(--accent-color);
            color: white;
            border-color: var(--accent-color);
        }
        
        /* Metrics Display Styles */
        .performance-metrics {
            display: flex;
            justify-content: space-between;
            margin-top: 1rem;
            gap: 1rem;
            flex-wrap: wrap;
        }
        
        .metric-card {
            flex: 1;
            min-width: 150px;
            background-color: #fff;
            padding: 0.75rem;
            border-radius: var(--border-radius);
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .metric-value {
            font-size: 1.5rem;
            font-weight: bold;
            margin: 0.5rem 0;
        }
        
        .metric-label {
            font-size: 0.85rem;
            color: #666;
        }
        
        /* Add styles for the node count slider */
        .node-count-control {
            margin-bottom: 1rem;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        .node-count-control label {
            margin-bottom: 0.5rem;
            font-weight: 500;
        }
        
        .slider {
            width: 80%;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Mesh Network Routing Visualization</h1>
            <p class="subtitle">Interactive Comparison of Routing Approaches</p>
        </div>
    </header>

    <nav>
        <div class="container">
            <ul>
                <li><a href="index.html">Overview</a></li>
                <li><a href="#routing" class="active">Routing</a></li>
                <li><a href="technical.html">Technical Details</a></li>
            </ul>
        </div>
    </nav>

    <main class="container">
        <section id="routing">
            <h2>Mesh Network Routing Visualization</h2>
            <p>This interactive visualization demonstrates the different routing approaches used by Meshtastic and MeshCore. Use the controls below to explore how packets are routed through the network.</p>
            
            <div class="legend">
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--meshtastic-color);"></div>
                    <span>Meshtastic Radio Wave</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: var(--meshcore-color);"></div>
                    <span>MeshCore Radio Wave</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #fd7e14;"></div>
                    <span>Discovery Wave</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #dc3545;"></div>
                    <span>Dropped Signal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #9c27b0;"></div>
                    <span>Route ACK Signal</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: rgba(76, 175, 80, 0.1); border: 1px dashed #4caf50;"></div>
                    <span>Node Transmission Range</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color" style="background-color: #dc3545;"></div>
                    <span>Red Flash: Duplicate Message Discarded</span>
                </div>
            </div>
            
            <div class="controls">
                <button id="btn-meshtastic" class="control-button meshtastic active">
                    <i class="fas fa-broadcast-tower"></i> Meshtastic Flooding
                </button>
                <button id="btn-meshcore-phase1" class="control-button meshcore">
                    <i class="fas fa-search"></i> MeshCore Path Discovery
                </button>
                <button id="btn-meshcore-phase2" class="control-button meshcore">
                    <i class="fas fa-route"></i> MeshCore Direct Routing
                </button>
                <button id="btn-compare" class="control-button action">
                    <i class="fas fa-balance-scale"></i> Compare Side-by-Side
                </button>
                <button id="btn-reset" class="control-button">
                    <i class="fas fa-redo"></i> Reset
                </button>
            </div>
            
            <div class="network-topology-selector">
                <h4>Network Topology:</h4>
                <div class="node-count-control">
                    <label for="node-count-slider">Node Count: <span id="node-count-value">90</span></label>
                    <input type="range" id="node-count-slider" min="10" max="150" value="90" class="slider">
                </div>
                <div class="topology-buttons">
                    <button id="topology-random" class="topology-button active">
                        <i class="fas fa-random"></i> Random
                    </button>
                    <button id="topology-dense" class="topology-button">
                        <i class="fas fa-th"></i> Dense
                    </button>
                    <button id="topology-sparse" class="topology-button">
                        <i class="fas fa-grip-vertical"></i> Sparse
                    </button>
                    <button id="topology-linear" class="topology-button">
                        <i class="fas fa-ellipsis-h"></i> Linear
                    </button>
                    <button id="topology-star" class="topology-button">
                        <i class="fas fa-asterisk"></i> Star
                    </button>
                </div>
            </div>
            
            <div class="visualization-container" id="network-visualization">
                <!-- D3.js will render the visualization here -->
            </div>
            
            <div class="phase-caption" id="phase-caption">
                Meshtastic Flooding: Radio signals propagate through all nodes within range, which rebroadcast once per message to maximize delivery probability.
            </div>
            
            <div class="performance-metrics">
                <div class="metric-card">
                    <div class="metric-label">Total Packets Sent</div>
                    <div class="metric-value" id="metric-packets">0</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Network Efficiency</div>
                    <div class="metric-value" id="metric-efficiency">0%</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Delivery Time</div>
                    <div class="metric-value" id="metric-time">0ms</div>
                </div>
                <div class="metric-card">
                    <div class="metric-label">Hops Required</div>
                    <div class="metric-value" id="metric-hops">0</div>
                </div>
            </div>
        </section>
        
        <section id="routing-comparison">
            <h2>Routing Methods Compared</h2>
            
            <div class="compare-container">
                <div class="compare-item compare-meshtastic">
                    <h3>Meshtastic Flooding Approach</h3>
                    <ul>
                        <li><strong>High redundancy:</strong> Messages are sent to all nodes within range, which rebroadcast to their neighbors</li>
                        <li><strong>Simple implementation:</strong> No complex routing tables or path discovery needed</li>
                        <li><strong>Higher delivery probability:</strong> Multiple paths increase chances of message delivery</li>
                        <li><strong>Bandwidth intensive:</strong> Network congestion increases with the number of nodes</li>
                        <li><strong>No path optimization:</strong> Uses the same bandwidth regardless of optimal paths</li>
                    </ul>
                </div>
                
                <div class="compare-item compare-meshcore">
                    <h3>MeshCore Selective Routing</h3>
                    <ul>
                        <li><strong>Path discovery phase:</strong> Initial flooding to find optimal route to destination</li>
                        <li><strong>Route establishment:</strong> Creates a persistent path between nodes</li>
                        <li><strong>Bandwidth efficiency:</strong> After path discovery, only nodes on the route forward packets</li>
                        <li><strong>Selective forwarding:</strong> Nodes not on the established route drop packets</li>
                        <li><strong>Adaptable routing:</strong> Routes can be re-established if network topology changes</li>
                    </ul>
                </div>
            </div>
            
            <div class="technical-section">
                <h3>Network Performance Considerations</h3>
                <p>The choice between flooding and selective routing depends on several factors:</p>
                <ul>
                    <li><strong>Network density:</strong> Dense networks benefit more from selective routing to reduce congestion</li>
                    <li><strong>Node reliability:</strong> Unreliable or mobile nodes may benefit from flooding's redundancy</li>
                    <li><strong>Message priority:</strong> MeshCore can prioritize critical messages while Meshtastic treats all messages equally</li>
                    <li><strong>Power consumption:</strong> Selective routing typically requires less overall transmission, saving power across the network</li>
                </ul>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2023 Mesh Networking Comparison. This is for informational purposes only.</p>
            <div class="footer-links">
                <a href="index.html">Overview</a>
                <a href="routing.html">Routing</a>
                <a href="technical.html">Technical Details</a>
            </div>
        </div>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // D3.js visualization code
            const width = document.getElementById('network-visualization').clientWidth;
            const height = document.getElementById('network-visualization').clientHeight;
            
            // Create SVG container
            const svg = d3.select('#network-visualization')
                .append('svg')
                .attr('width', width)
                .attr('height', height);
            
            // Create a group for the network
            const networkGroup = svg.append('g')
                .attr('class', 'network-group');
            
            // Add tooltip for nodes
            const tooltip = d3.select('body')
                .append('div')
                .attr('class', 'tooltip')
                .style('opacity', 0);
            
            // Performance metrics tracking variables
            let metrics = {
                packetsSent: 0,
                efficiency: 0,
                deliveryTime: 0,
                hopsRequired: 0
            };
            
            // Node count configuration
            let nodeCount = 90; // Default node count
            
            // Add event listener for node count slider
            document.getElementById('node-count-slider').addEventListener('input', function() {
                nodeCount = parseInt(this.value);
                document.getElementById('node-count-value').textContent = nodeCount;
            });
            
            document.getElementById('node-count-slider').addEventListener('change', function() {
                // Regenerate network with new node count when slider is released
                generateNetwork(currentTopology);
            });
            
            // Topology configurations
            const topologies = {
                random: {
                    name: "Random",
                    description: "Nodes are randomly distributed with varied connectivity",
                    generate: generateRandomTopology
                },
                dense: {
                    name: "Dense",
                    description: "Highly connected network with many redundant paths",
                    generate: generateDenseTopology
                },
                sparse: {
                    name: "Sparse",
                    description: "Limited connectivity with few redundant paths",
                    generate: generateSparseTopology
                },
                linear: {
                    name: "Linear",
                    description: "Nodes form a chain with limited alternative routes",
                    generate: generateLinearTopology
                },
                star: {
                    name: "Star",
                    description: "Central node connects to all others with minimal peripheral connections",
                    generate: generateStarTopology
                }
            };
            
            // Current topology
            let currentTopology = "random";
            
            // Generate network based on selected topology
            let nodes = [];
            let links = [];
            generateNetwork(currentTopology);
            
            // Event listeners for topology buttons
            document.querySelectorAll('.topology-button').forEach(button => {
                button.addEventListener('click', function() {
                    const topologyType = this.id.split('-')[1]; // Extract topology type from button ID
                    
                    // Update active button
                    document.querySelectorAll('.topology-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    this.classList.add('active');
                    
                    // Generate new network with selected topology
                    currentTopology = topologyType;
                    generateNetwork(topologyType);
                    
                    // Reset any active simulation
                    resetVisualization();
                    
                    // Update caption
                    document.getElementById('phase-caption').innerText = 
                        `Network Topology: ${topologies[topologyType].name} - ${topologies[topologyType].description}`;
                });
            });
            
            // Add event listeners for control buttons
            document.getElementById('btn-meshtastic').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run Meshtastic flooding simulation
                animateMeshtasticFlooding();
            });
            
            document.getElementById('btn-meshcore-phase1').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run MeshCore path discovery simulation
                animateMeshcoreDiscovery();
            });
            
            document.getElementById('btn-meshcore-phase2').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run MeshCore direct routing simulation
                animateMeshcoreDirectRouting();
            });
            
            document.getElementById('btn-compare').addEventListener('click', function() {
                // Update active state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                this.classList.add('active');
                
                // Run comparison view
                animateComparison();
            });
            
            document.getElementById('btn-reset').addEventListener('click', function() {
                // Reset visualization
                resetVisualization();
                
                // Reset active button state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById('btn-meshtastic').classList.add('active');
                
                // Reset metrics
                resetMetrics();
                
                // Reset caption
                document.getElementById('phase-caption').innerText = 
                    'Select a routing method to visualize different approaches to mesh networking.';
            });
            
            // Function to generate network based on topology
            function generateNetwork(topologyType) {
                // Clear existing network
                networkGroup.selectAll('*').remove();
                
                // Get topology generator function
                const topologyGenerator = topologies[topologyType].generate;
                
                // Generate nodes and links
                const generatedNetwork = topologyGenerator();
                nodes = generatedNetwork.nodes;
                links = generatedNetwork.links;
                
                // Draw the network
                drawNetwork();
                
                // Reset metrics
                resetMetrics();
            }
            
            // Function to generate random topology
            function generateRandomTopology() {
                // Define nodes with random positions and ranges
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: getRandomRange(120, 200) }
                ];
                
                // Add regular nodes (using configurable nodeCount)
                const regularNodeCount = nodeCount - 2; // Minus source and destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    
                    // Create highly variable node ranges between 20px and 200px
                    let range;
                    if (i % 5 === 0) {
                        // 20% of nodes get very small ranges (20-40px)
                        range = getRandomRange(20, 40);
                    } else if (i % 5 === 1) {
                        // 20% of nodes get small ranges (40-80px)
                        range = getRandomRange(40, 80);
                    } else if (i % 5 === 2) {
                        // 20% of nodes get medium ranges (80-120px)
                        range = getRandomRange(80, 120);
                    } else if (i % 5 === 3) {
                        // 20% of nodes get large ranges (120-160px)
                        range = getRandomRange(120, 160);
                    } else {
                        // 20% of nodes get very large ranges (160-200px)
                        range = getRandomRange(160, 200);
                    }
                    
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: range
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: getRandomRange(120, 200) });
                
                // Assign random positions with grid-like distribution for better coverage
                const gridSize = Math.ceil(Math.sqrt(nodes.length));
                const cellWidth = width / gridSize;
                const cellHeight = height / gridSize;
                
                nodes.forEach((node, index) => {
                    // Calculate grid position
                    const gridX = index % gridSize;
                    const gridY = Math.floor(index / gridSize);
                    
                    // Add some randomness within the cell
                    const jitterX = (Math.random() - 0.5) * cellWidth * 0.7;
                    const jitterY = (Math.random() - 0.5) * cellHeight * 0.7;
                    
                    node.x = (gridX + 0.5) * cellWidth + jitterX;
                    node.y = (gridY + 0.5) * cellHeight + jitterY;
                });
                
                // Override specific node positions for source and destination
                // Place A at left side
                nodes[0].x = width * 0.05;
                nodes[0].y = height * 0.5;
                
                // Place Z at right side
                nodes[nodes.length - 1].x = width * 0.95;
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Create links based on range
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate dense topology
            function generateDenseTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 180 }
                ];
                
                // Add regular nodes (using configurable nodeCount)
                const regularNodeCount = nodeCount - 2; // Minus source and destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    
                    // For dense topology, create a more uniform but still variable range distribution
                    // Skew toward larger ranges but include some smaller ones
                    let range;
                    if (i % 8 === 0) {
                        // Some nodes get small ranges (40-60px)
                        range = getRandomRange(40, 60);
                    } else if (i % 8 === 1) {
                        // Some nodes get medium ranges (80-100px)
                        range = getRandomRange(80, 100);
                    } else {
                        // Most nodes get large ranges to create density (120-180px)
                        range = getRandomRange(120, 180);
                    }
                    
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: range
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 180 });
                
                // Position in a grid pattern with clustering for density
                const gridSize = Math.ceil(Math.sqrt(nodes.length * 0.7)); // Use 70% of full grid for clustering
                const cellWidth = width / gridSize;
                const cellHeight = height / gridSize;
                
                nodes.forEach((node, index) => {
                    if (index === 0) return; // Skip source node A
                    if (index === nodes.length - 1) return; // Skip destination node Z
                    
                    // Calculate grid position
                    const gridX = (index - 1) % gridSize;
                    const gridY = Math.floor((index - 1) / gridSize);
                    
                    // Add some randomness within the cell, but keep it dense
                    const jitterX = (Math.random() - 0.5) * cellWidth * 0.5;
                    const jitterY = (Math.random() - 0.5) * cellHeight * 0.5;
                    
                    node.x = (width * 0.2) + (gridX + 0.5) * cellWidth * 0.8 + jitterX;
                    node.y = (height * 0.1) + (gridY + 0.5) * cellHeight + jitterY;
                });
                
                // Place A and Z at strategic positions
                nodes[0].x = width * 0.05; // A at left side
                nodes[0].y = height * 0.5;
                nodes[nodes.length - 1].x = width * 0.95; // Z at right side
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Create links based on range - dense means every node can reach many others
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate sparse topology
            function generateSparseTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 100 }
                ];
                
                // Add regular nodes (using configurable nodeCount)
                const regularNodeCount = nodeCount - 2; // Minus source and destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    
                    // For sparse topology, most nodes have smaller ranges
                    let range;
                    if (i % 10 === 0) {
                        // Few nodes get large ranges (150-200px) to create some connectivity
                        range = getRandomRange(150, 200);
                    } else if (i % 5 === 0) {
                        // Some nodes get medium ranges (80-120px)
                        range = getRandomRange(80, 120);
                    } else {
                        // Most nodes get small ranges to create sparsity (20-60px)
                        range = getRandomRange(20, 60);
                    }
                    
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: range
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 100 });
                
                // Position to create sparse network - spread nodes widely
                const gridSize = Math.ceil(Math.sqrt(nodes.length * 1.5)); // Use 150% of normal grid to create sparsity
                const cellWidth = width / gridSize;
                const cellHeight = height / gridSize;
                
                nodes.forEach((node, index) => {
                    if (index === 0) return; // Skip source node A
                    if (index === nodes.length - 1) return; // Skip destination node Z
                    
                    // Calculate grid position
                    const gridX = (index - 1) % gridSize;
                    const gridY = Math.floor((index - 1) / gridSize);
                    
                    // Add significant randomness to create sparsity
                    const jitterX = (Math.random() - 0.5) * cellWidth * 0.9;
                    const jitterY = (Math.random() - 0.5) * cellHeight * 0.9;
                    
                    node.x = (gridX + 0.5) * cellWidth + jitterX;
                    node.y = (gridY + 0.5) * cellHeight + jitterY;
                    
                    // Ensure nodes stay within bounds
                    node.x = Math.max(20, Math.min(width - 20, node.x));
                    node.y = Math.max(20, Math.min(height - 20, node.y));
                });
                
                // Place A and Z at strategic positions
                nodes[0].x = width * 0.05; // A at left side
                nodes[0].y = height * 0.5;
                nodes[nodes.length - 1].x = width * 0.95; // Z at right side
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Create links based on range - sparse means fewer links
                const links = [];
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate linear topology
            function generateLinearTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 120 }
                ];
                
                // Add regular nodes (using configurable nodeCount)
                const regularNodeCount = nodeCount - 2; // Minus source and destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    
                    // For linear topology, create a mix of ranges
                    let range;
                    if (i % 8 === 0) {
                        // Some nodes get very large ranges to bridge potential gaps (160-200px)
                        range = getRandomRange(160, 200);
                    } else if (i % 4 === 0) {
                        // Some nodes get medium ranges (80-120px)
                        range = getRandomRange(80, 120);
                    } else {
                        // Most nodes get smaller ranges (30-70px)
                        range = getRandomRange(30, 70);
                    }
                    
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: range
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 120 });
                
                // Position in a meandering line with some branches
                // Main path nodes
                const mainPathNodes = 40; // About half the nodes form the main path
                const step = width * 0.9 / (mainPathNodes - 1);
                
                for (let i = 0; i < mainPathNodes; i++) {
                    const nodeIndex = i === 0 ? 0 : (i === mainPathNodes - 1 ? nodes.length - 1 : i);
                    nodes[nodeIndex].x = width * 0.05 + (step * i);
                    nodes[nodeIndex].y = height * 0.5 + (Math.sin(i * 0.5) * height * 0.2); // Sinusoidal path
                }
                
                // Position the rest of the nodes as branches off the main path
                for (let i = 1; i < nodes.length - 1; i++) {
                    // Skip nodes already positioned in the main path
                    if (i < mainPathNodes && i !== nodes.length - 1) continue;
                    
                    // Choose a random node from the main path to branch from
                    const branchFrom = Math.floor(Math.random() * mainPathNodes);
                    
                    // Position node as a branch with random angle and distance
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 40 + Math.random() * 80; // Between 40-120px from parent
                    
                    nodes[i].x = nodes[branchFrom === 0 ? 0 : (branchFrom === mainPathNodes - 1 ? nodes.length - 1 : branchFrom)].x + Math.cos(angle) * distance;
                    nodes[i].y = nodes[branchFrom === 0 ? 0 : (branchFrom === mainPathNodes - 1 ? nodes.length - 1 : branchFrom)].y + Math.sin(angle) * distance;
                    
                    // Ensure nodes stay within bounds
                    nodes[i].x = Math.max(20, Math.min(width - 20, nodes[i].x));
                    nodes[i].y = Math.max(20, Math.min(height - 20, nodes[i].y));
                }
                
                // Ensure source and destination are at the ends
                nodes[0].x = width * 0.05;
                nodes[0].y = height * 0.5;
                nodes[nodes.length - 1].x = width * 0.95;
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Create links - for linear, we primarily connect adjacent nodes plus some random cross links
                const links = [];
                
                // Connect main path
                for (let i = 0; i < mainPathNodes - 1; i++) {
                    const sourceIndex = i === 0 ? 0 : i;
                    const targetIndex = i === mainPathNodes - 2 ? nodes.length - 1 : i + 1;
                    
                    links.push({
                        source: nodes[sourceIndex].id,
                        target: nodes[targetIndex].id,
                        distance: 1
                    });
                }
                
                // Add links based on range for the rest of the network
                for (let i = 0; i < nodes.length; i++) {
                    for (let j = i + 1; j < nodes.length; j++) {
                        // Skip if already connected through main path
                        if (links.some(link => 
                            (link.source === nodes[i].id && link.target === nodes[j].id) || 
                            (link.source === nodes[j].id && link.target === nodes[i].id))) {
                            continue;
                        }
                        
                        if (isInRange(nodes[i], nodes[j])) {
                            links.push({
                                source: nodes[i].id,
                                target: nodes[j].id,
                                distance: 1
                            });
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Function to generate star topology
            function generateStarTopology() {
                const nodes = [
                    { id: 'A', name: 'Node A (Source)', type: 'source', range: 200 }
                ];
                
                // Add regular nodes (using configurable nodeCount)
                const regularNodeCount = nodeCount - 2; // Minus source and destination
                for (let i = 0; i < regularNodeCount; i++) {
                    const nodeId = i < 7 ? String.fromCharCode(66 + i) : 'N' + (i - 6); // B,C,D,E,F,G,H, then N1, N2, etc.
                    
                    // Create variable ranges for star topology
                    let range;
                    if (i === 3) { // Node E - hub node
                        // Hub node gets the maximum range
                        range = 200;
                    } else if (i < 7) {
                        // Main alphabet nodes get medium-large ranges (100-150px)
                        range = getRandomRange(100, 150);
                    } else {
                        // Other nodes get smaller ranges (20-80px)
                        range = getRandomRange(20, 80);
                    }
                    
                    nodes.push({ 
                        id: nodeId, 
                        name: 'Node ' + nodeId, 
                        type: 'node', 
                        range: range
                    });
                }
                
                // Add destination node
                nodes.push({ id: 'Z', name: 'Node Z (Destination)', type: 'destination', range: 120 });
                
                // Select a hub node (E will be our hub)
                const hubIndex = 4; // Index of node E
                nodes[hubIndex].name = 'Node E (Hub)';
                nodes[hubIndex].range = 200; // Increase range for the hub
                
                // Position with hub (E) in the center
                nodes[hubIndex].x = width * 0.5; // E at center
                nodes[hubIndex].y = height * 0.5;
                
                // Position source (A) and destination (Z) at opposite sides
                nodes[0].x = width * 0.05; // A at left
                nodes[0].y = height * 0.5;
                nodes[nodes.length - 1].x = width * 0.95; // Z at right
                nodes[nodes.length - 1].y = height * 0.5;
                
                // Position other nodes in concentric circles around the hub
                const clusters = 5; // Number of clusters
                const nodesPerCluster = Math.ceil((nodes.length - 3) / clusters); // Nodes per cluster, excluding A, E, and Z
                
                let nodeIndex = 1;
                for (let cluster = 0; cluster < clusters; cluster++) {
                    const radius = (cluster + 1) * (Math.min(width, height) * 0.35 / clusters);
                    const nodesInThisCluster = Math.min(nodesPerCluster, nodes.length - 3 - (cluster * nodesPerCluster));
                    
                    for (let i = 0; i < nodesInThisCluster; i++) {
                        if (nodeIndex === hubIndex) {
                            nodeIndex++; // Skip the hub node
                        }
                        
                        if (nodeIndex >= nodes.length - 1) break; // Skip Z (last node)
                        
                        const angle = (i * (2 * Math.PI / nodesInThisCluster));
                        nodes[nodeIndex].x = nodes[hubIndex].x + radius * Math.cos(angle);
                        nodes[nodeIndex].y = nodes[hubIndex].y + radius * Math.sin(angle);
                        
                        nodeIndex++;
                    }
                }
                
                // Create links - everything connects to the center and nearby nodes in same cluster
                const links = [];
                
                // Connect hub to source and destination
                links.push({
                    source: nodes[0].id, // A (source)
                    target: nodes[hubIndex].id, // E (hub)
                    distance: 1
                });
                
                links.push({
                    source: nodes[hubIndex].id, // E (hub)
                    target: nodes[nodes.length - 1].id, // Z (destination)
                    distance: 1
                });
                
                // Connect all nodes to the hub and to nearby nodes based on range
                for (let i = 0; i < nodes.length; i++) {
                    if (i !== hubIndex && i !== 0 && i !== nodes.length - 1) {
                        // Connect to hub if in range
                        if (isInRange(nodes[i], nodes[hubIndex])) {
                            links.push({
                                source: nodes[hubIndex].id,
                                target: nodes[i].id,
                                distance: 1
                            });
                        }
                        
                        // Connect to nearby nodes based on range
                        for (let j = i + 1; j < nodes.length; j++) {
                            if (j !== hubIndex && isInRange(nodes[i], nodes[j])) {
                                links.push({
                                    source: nodes[i].id,
                                    target: nodes[j].id,
                                    distance: 1
                                });
                            }
                        }
                    }
                }
                
                return { nodes, links };
            }
            
            // Draw the network
            function drawNetwork() {
                // Draw node ranges first so they're in the background
                const nodeRanges = networkGroup.selectAll('.node-range')
                    .data(nodes)
                    .enter()
                    .append('circle')
                    .attr('class', d => `node-range ${d.id === 'A' ? 'meshtastic-range' : d.id === 'Z' ? 'meshcore-range' : ''}`)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', d => d.range)
                    .attr('fill', d => {
                        if (d.type === 'source') return 'rgba(76, 175, 80, 0.1)';
                        if (d.type === 'destination') return 'rgba(233, 30, 99, 0.1)';
                        return 'rgba(200, 200, 200, 0.1)';
                    })
                    .attr('stroke', d => {
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        return '#ccc';
                    });
                
                // No longer draw static link lines
                
                // Draw nodes
                const nodeElements = networkGroup.selectAll('.network-node')
                    .data(nodes)
                    .enter()
                    .append('circle')
                    .attr('class', d => `network-node node-${d.id}`)
                    .attr('cx', d => d.x)
                    .attr('cy', d => d.y)
                    .attr('r', d => {
                        // Make source and destination nodes larger
                        if (d.type === 'source' || d.type === 'destination') return 16;
                        // Make hub nodes slightly larger 
                        if (d.id === 'E' || d.name.includes('Hub')) return 14;
                        // Make original nodes (B-H) slightly larger
                        if (d.id.length === 1) return 12;
                        // Make all other nodes smaller
                        return 8;
                    })
                    .attr('fill', d => {
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        if (d.id === 'E' || d.name.includes('Hub')) return '#ff9800';
                        return '#ddd';
                    })
                    .attr('stroke', '#fff')
                    .attr('stroke-width', 2)
                    .on('mouseover', function(event, d) {
                        tooltip.transition()
                            .duration(200)
                            .style('opacity', 0.9);
                        tooltip.html(`${d.name}<br>Range: ${d.range}px`)
                            .style('left', (event.pageX + 10) + 'px')
                            .style('top', (event.pageY - 28) + 'px');
                    })
                    .on('mouseout', function() {
                        tooltip.transition()
                            .duration(500)
                            .style('opacity', 0);
                    });
                
                // Add node labels only for source, destination and original nodes
                const nodeLabels = networkGroup.selectAll('.node-label')
                    .data(nodes.filter(d => d.id.length === 1)) // Only show labels for A-Z nodes
                    .enter()
                    .append('text')
                    .attr('class', 'node-label')
                    .attr('x', d => d.x)
                    .attr('y', d => d.y)
                    .attr('font-size', d => {
                        if (d.type === 'source' || d.type === 'destination') return '14px';
                        if (d.id === 'E' || d.name.includes('Hub')) return '12px';
                        return '10px';
                    })
                    .text(d => d.id);
            }
            
            // Reset metrics display
            function resetMetrics() {
                metrics = {
                    packetsSent: 0,
                    efficiency: 0,
                    deliveryTime: 0,
                    hopsRequired: 0
                };
                
                // Update display
                document.getElementById('metric-packets').textContent = '0';
                document.getElementById('metric-efficiency').textContent = '0%';
                document.getElementById('metric-time').textContent = '0ms';
                document.getElementById('metric-hops').textContent = '0';
            }
            
            // Update metrics
            function updateMetrics(data) {
                // Update metrics object
                Object.assign(metrics, data);
                
                // Update display
                if ('packetsSent' in data) {
                    document.getElementById('metric-packets').textContent = metrics.packetsSent;
                }
                if ('efficiency' in data) {
                    document.getElementById('metric-efficiency').textContent = `${Math.round(metrics.efficiency * 100)}%`;
                }
                if ('deliveryTime' in data) {
                    document.getElementById('metric-time').textContent = `${metrics.deliveryTime}ms`;
                }
                if ('hopsRequired' in data) {
                    document.getElementById('metric-hops').textContent = metrics.hopsRequired;
                }
            }
            
            // Ensure these existing functions take metrics into account
            
            // Utility functions
            function randomPosition(paddingPercent = 0.1) {
                const padding = Math.min(width, height) * paddingPercent;
                return {
                    x: Math.random() * (width - 2 * padding) + padding,
                    y: Math.random() * (height - 2 * padding) + padding
                };
            }
            
            function getRandomRange(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }
            
            function isInRange(nodeA, nodeB) {
                const dx = nodeA.x - nodeB.x;
                const dy = nodeA.y - nodeB.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                // Nodes are connected if either one's range reaches the other
                return distance <= nodeA.range || distance <= nodeB.range;
            }
            
            // Animation functions
            function createPacket(sourceNode, targetNode, packetClass) {
                // Calculate signal quality based on distance between nodes
                const dx = sourceNode.x - targetNode.x;
                const dy = sourceNode.y - targetNode.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                // Calculate signal quality (0-1) based on distance and range
                // Higher quality = closer to 1
                const signalQuality = Math.max(0, Math.min(1, 1 - (distance / sourceNode.range)));
                
                // We'll now return an object with necessary data, but won't create a moving packet
                return {
                    sourceNode,
                    targetNode,
                    packetClass,  // Store the exact packet class as passed
                    signalQuality
                };
            }
            
            function animatePacket(packetData, sourceNode, targetNode, duration, delay, callback) {
                // Get signal quality from the packet data
                let signalQuality = packetData.signalQuality || 0.5;
                
                // Create expanding ring effect with opacity based on signal quality
                const packetType = packetData.packetClass.includes('meshtastic') ? 'meshtastic-ring' :
                                 packetData.packetClass.includes('discovery') ? 'discovery-ring' : 
                                 packetData.packetClass.includes('meshcore') ? 'meshcore-ring' : 
                                 packetData.packetClass.includes('ack') ? 'ack-ring' : 'dropped-ring';
                
                const ringOpacity = 0.3 + (signalQuality * 0.5); // Ring opacity based on signal quality
                
                // Create first ring at source node
                const sourceRing = networkGroup.append('circle')
                    .attr('class', `packet-ring ${packetType}`)
                    .attr('cx', sourceNode.x)
                    .attr('cy', sourceNode.y)
                    .attr('r', 10)
                    .attr('stroke-opacity', ringOpacity)
                    .attr('stroke-width', 2);
                
                // Animate the expanding ring at source
                sourceRing.transition()
                    .duration(duration * 0.7) // Make it faster than previous animation
                    .attr('r', sourceNode.range)
                    .attr('stroke-opacity', 0)
                    .remove();
                
                // After a delay, show a flash at the target node to indicate reception
                setTimeout(() => {
                    // Don't change color for nodes that drop packets
                    if (!packetData.packetClass.includes('dropped')) {
                        // Mark the node as having received a message with a CSS class for tracking
                        networkGroup.selectAll('.network-node')
                            .filter(d => d.id === targetNode.id)
                            .classed('message-received', true);
                        
                        // Update the target node's radius visualization based on received message type
                        if (packetData.packetClass === 'packet-ack') {
                            // If receiving an ACK, update the radius to purple interior
                            networkGroup.selectAll('.node-range')
                                .filter(d => d.id === targetNode.id)
                                .classed('has-received-message', true)
                                .classed('has-received-ack', true);
                        } else {
                            // For regular messages, update the radius to green interior
                            networkGroup.selectAll('.node-range')
                                .filter(d => d.id === targetNode.id)
                                .classed('has-received-message', true);
                        }
                        
                        let nodeColor;
                        
                        // Determine color based on the exact packet class
                        if (packetData.packetClass === 'packet-ack') {
                            // Purple for ACK messages (during the ACK phase)
                            nodeColor = '#9c27b0';
                        } else {
                            // Green for all other message types (discovery or data)
                            nodeColor = '#4caf50';
                        }
                        
                        // Change target node color and leave it that color
                        networkGroup.selectAll('.network-node')
                            .filter(d => d.id === targetNode.id)
                            .transition()
                            .duration(200)
                            .attr('r', d => { 
                                if (d.type === 'source' || d.type === 'destination') return 20;
                                if (d.id.length === 1) return 16;
                                return 12; 
                            })
                            .attr('fill', nodeColor) // Change node color based on packet type
                            .transition()
                            .duration(200)
                            .attr('r', d => {
                                if (d.type === 'source' || d.type === 'destination') return 16;
                                if (d.id.length === 1) return 12;
                                return 8;
                            });
                    }
                    
                    // Execute the callback
                    if (callback) callback();
                }, delay + duration * 0.6); // Trigger reception effect before animation fully completes
                
                return sourceRing; // Return the ring element for reference
            }
            
            function createFloodWave(sourceNode, waveClass) {
                const wave = networkGroup.append('circle')
                    .attr('class', `flood-wave ${waveClass}`)
                    .attr('cx', sourceNode.x)
                    .attr('cy', sourceNode.y)
                    .attr('r', 10)
                    .attr('stroke-opacity', 0.9) // More visible
                    .attr('stroke-width', 3);  // Thicker stroke
                
                // Animate the wave
                wave.transition()
                    .duration(2000)
                    .attr('r', sourceNode.range)
                    .attr('stroke-opacity', 0)
                    .remove();
            }
            
            function highlightOptimalPath() {
                // Find optimal path
                const path = findOptimalPath();
                
                if (path.length < 2) {
                    console.warn("No valid path found to highlight");
                    return;
                }
                
                // Highlight nodes along the path
                networkGroup.selectAll('.network-node')
                    .filter(d => path.includes(d.id) && d.id !== 'A' && d.id !== 'Z')
                    .transition()
                    .duration(500)
                    .attr('fill', '#43a047'); // Meshcore color
                
                // Create pulsing effect between nodes on the path
                for (let i = 0; i < path.length - 1; i++) {
                    const sourceNode = nodes.find(n => n.id === path[i]);
                    const targetNode = nodes.find(n => n.id === path[i+1]);
                    
                    // Draw a temporary line between nodes
                    const pathLine = networkGroup.append('line')
                        .attr('class', 'path-highlight-line')
                        .attr('x1', sourceNode.x)
                        .attr('y1', sourceNode.y)
                        .attr('x2', targetNode.x)
                        .attr('y2', targetNode.y)
                        .attr('stroke', '#43a047')
                        .attr('stroke-width', 4)
                        .attr('stroke-opacity', 0.8)
                        .attr('stroke-dasharray', '5,5');
                    
                    // Add pulsing animation
                    pathLine.transition()
                        .duration(1000)
                        .attr('stroke-opacity', 0.3)
                        .transition()
                        .duration(1000)
                        .attr('stroke-opacity', 0.8)
                        .on('end', function repeat() {
                            d3.select(this)
                                .transition()
                                .duration(1000)
                                .attr('stroke-opacity', 0.3)
                                .transition()
                                .duration(1000)
                                .attr('stroke-opacity', 0.8)
                                .on('end', repeat);
                        });
                }
            }
            
            // Find optimal path based on distance and connections
            function findOptimalPath() {
                // Simple breadth-first search to find a path
                const queue = [{ id: 'A', path: ['A'] }];
                const visited = new Set(['A']);
                
                while (queue.length > 0) {
                    const { id, path } = queue.shift();
                    
                    // If we reached Z, return the path
                    if (id === 'Z') {
                        return path;
                    }
                    
                    // Find all connected nodes
                    const connectedLinks = links.filter(link => 
                        (link.source === id || link.target === id));
                    
                    for (const link of connectedLinks) {
                        const nextId = link.source === id ? link.target : link.source;
                        if (!visited.has(nextId)) {
                            visited.add(nextId);
                            queue.push({ id: nextId, path: [...path, nextId] });
                        }
                    }
                }
                
                // If no path found, return a default path or empty array
                console.warn("No path found between A and Z");
                return [];
            }
            
            // Find optimal path dynamically based on network topology
            const optimalPath = findOptimalPath();
            
            function animateMeshcoreDiscovery() {
                // Reset visualization
                resetVisualization();
                
                // Reset metrics
                resetMetrics();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'MeshCore Path Discovery: Initial radio wave propagation to find the optimal path to the destination.';
                
                // Find nodes by ID
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                // Sets to track nodes at different stages:
                const pendingBroadcast = new Set(); // Nodes queued to broadcast
                const hasNodeBroadcast = new Set(['A']); // Nodes that have already broadcast (completed)
                let totalPackets = 0;
                let hasReachedDestination = false;
                
                // Start timing for delivery time metric
                const startTime = Date.now();
                
                // Constants to control flooding visualization
                const MAX_CONCURRENT_ANIMATIONS = 25; // Limit number of concurrent animations
                const MAX_FLOOD_DEPTH = 7; // Limit flood depth for path discovery (was limited to 3 before)
                let activeAnimations = 0;
                const discoveryQueue = []; // Queue for pending discovery broadcasts
                
                // Create a flood wave from source node (only for key nodes)
                if (nodeMap['A'].id.length === 1) {
                    createFloodWave(nodeMap['A'], 'meshcore-wave');
                }
                
                // Start the discovery flood from node A
                startDiscoveryFlood('A', 0);
                
                function startDiscoveryFlood(nodeId, depth) {
                    if (depth > MAX_FLOOD_DEPTH) return; // Limit recursion depth
                    
                    const sourceNode = nodes.find(n => n.id === nodeId);
                    
                    // Create a visible flood wave from key nodes to reduce visual clutter
                    if (nodeId.length === 1) {
                        createFloodWave(sourceNode, 'discovery-wave');
                    }
                        
                        // Mark this node as having broadcast
                    hasNodeBroadcast.add(nodeId);
                    // Remove from pending if it was there
                    pendingBroadcast.delete(nodeId);
                    
                    // Get all connections for this node
                    const nodeLinks = links.filter(link => 
                        (link.source === nodeId || link.target === nodeId));
                    
                    // Process all node connections, queue if too many for animation
                    nodeLinks.forEach((link, index) => {
                        const targetId = link.source === nodeId ? link.target : link.source;
                        
                        // Skip if the target has already broadcast or is pending
                        if (hasNodeBroadcast.has(targetId) || pendingBroadcast.has(targetId)) {
                                        setTimeout(() => {
                                            showDroppedMessageEffect(nodeMap[targetId]);
                            }, 200 + (Math.min(index, 10) * 50)); // Stagger dropped effects
                            return;
                        }
                        
                        // Mark this node as pending broadcast to prevent duplicates
                        pendingBroadcast.add(targetId);
                        
                        // Check if we're already at the animation limit
                                if (activeAnimations >= MAX_CONCURRENT_ANIMATIONS) {
                            // Queue this broadcast
                            discoveryQueue.push({
                                sourceId: nodeId,
                                targetId: targetId,
                                depth: depth,
                                delay: 300
                            });
                                    return;
                                }
                                
                        // Create packet data
                        const packetData = createPacket(nodeMap[nodeId], nodeMap[targetId], 'packet-discovery');
                                
                        // Increment packet count and active animations
                                totalPackets++;
                                activeAnimations++;
                                updateMetrics({ packetsSent: totalPackets });
                                
                        // Stagger animation start times, but cap to avoid long delays
                        const staggerDelay = Math.min(index, 10) * 50;
                                    
                        animatePacket(packetData, nodeMap[nodeId], nodeMap[targetId], 500, 200 + staggerDelay, function() {
                            // Decrement active animations count
                                    activeAnimations--;
                                    
                            // Process next wave if this node hasn't broadcast yet
                            if (!hasNodeBroadcast.has(targetId)) {
                                // If we reached the destination Z, update status
                                if (targetId === 'Z' && !hasReachedDestination) {
                                        hasReachedDestination = true;
                                        flashDestinationNode();
                                    }
                                    
                                // Queue this node to broadcast in the next wave
                                discoveryQueue.push({
                                    sourceId: targetId,
                                    targetId: null, // No specific target for flooding
                                    depth: depth + 1,
                                    delay: 500
                                });
                            } else {
                                // Already broadcast, remove from pending
                                pendingBroadcast.delete(targetId);
                            }
                            
                            // Process the queue immediately if we're below the animation limit
                            if (activeAnimations < MAX_CONCURRENT_ANIMATIONS / 2) {
                                processDiscoveryQueue();
                            }
                        });
                    });
                    
                    // Process queue after a delay if no animations were started
                    if (activeAnimations === 0) {
                        setTimeout(processDiscoveryQueue, 500);
                    }
                }
                
                function processDiscoveryQueue() {
                    // Process up to the max concurrent animations limit
                    let processed = 0;
                    const batchSize = Math.min(MAX_CONCURRENT_ANIMATIONS, 10);
                    
                    while (discoveryQueue.length > 0 && activeAnimations < MAX_CONCURRENT_ANIMATIONS && processed < batchSize) {
                        const nextBroadcast = discoveryQueue.shift();
                        processed++;
                        
                        if (nextBroadcast.targetId === null) {
                            // This is a flooding request
                            
                            // Only process if node hasn't broadcast yet
                            if (!hasNodeBroadcast.has(nextBroadcast.sourceId)) {
                                setTimeout(function() {
                                    startDiscoveryFlood(nextBroadcast.sourceId, nextBroadcast.depth);
                                }, nextBroadcast.delay);
                            } else {
                                // Already broadcast, remove from pending if needed
                                pendingBroadcast.delete(nextBroadcast.sourceId);
                            }
                        } else {
                            // This is a directed packet
                            
                            // Skip if target has already broadcast or is pending
                            if (hasNodeBroadcast.has(nextBroadcast.targetId) || pendingBroadcast.has(nextBroadcast.targetId)) {
                                // Show dropped message effect
                                setTimeout(() => {
                                    showDroppedMessageEffect(nodeMap[nextBroadcast.targetId]);
                                }, 200);
                                continue;
                            }
                            
                            // Mark as pending to prevent duplicates
                            pendingBroadcast.add(nextBroadcast.targetId);
                            
                            // Create packet data
                            const packetData = createPacket(nodeMap[nextBroadcast.sourceId], nodeMap[nextBroadcast.targetId], 'packet-discovery');
                            
                            // Increment packet count and active animations
                                totalPackets++;
                                activeAnimations++;
                                updateMetrics({ packetsSent: totalPackets });
                                
                            animatePacket(packetData, nodeMap[nextBroadcast.sourceId], nodeMap[nextBroadcast.targetId], 500, 0, function() {
                                // Decrement active animations count
                                    activeAnimations--;
                                    
                                // If this node hasn't broadcast yet, queue it
                                if (!hasNodeBroadcast.has(nextBroadcast.targetId)) {
                                    // Check if we reached the destination
                                    if (nextBroadcast.targetId === 'Z' && !hasReachedDestination) {
                                        hasReachedDestination = true;
                                        flashDestinationNode();
                                    }
                                    
                                    // Queue for next wave
                                    discoveryQueue.push({
                                        sourceId: nextBroadcast.targetId,
                                        targetId: null,
                                        depth: nextBroadcast.depth + 1,
                                        delay: 300
                                    });
                                } else {
                                    // Already broadcast, remove from pending
                                    pendingBroadcast.delete(nextBroadcast.targetId);
                                }
                                
                                // Process more from the queue
                                if (discoveryQueue.length > 0 && activeAnimations < MAX_CONCURRENT_ANIMATIONS / 2) {
                                    processDiscoveryQueue();
                                }
                            });
                        }
                    }
                    
                    // If there are still items in the queue, schedule another processing round
                    if (discoveryQueue.length > 0) {
                        setTimeout(processDiscoveryQueue, 400);
                    } else if (activeAnimations === 0 && !hasReachedDestination) {
                        // If queue is empty and no animations are running, but Z hasn't received a message,
                        // this means the message couldn't reach Z - show an error
                        document.getElementById('phase-caption').innerText = 
                            'MeshCore Path Discovery: Unable to reach destination. The network topology does not provide a path.';
                    }
                }
                
                function flashDestinationNode() {
                    // Flash destination node to indicate receipt
                    networkGroup.selectAll('.network-node')
                        .filter(d => d.id === 'Z')
                        .transition()
                        .duration(300)
                        .attr('r', d => d.type === 'destination' ? 20 : 14)
                        .transition()
                        .duration(300)
                        .attr('r', d => d.type === 'destination' ? 16 : 12);
                        
                    // Update caption to indicate destination reached but flooding continues
                    document.getElementById('phase-caption').innerText = 
                        'MeshCore Path Discovery: Destination reached, but flooding continues throughout the network.';
                        
                    // Schedule ACK phase to start after the destination receives the message
                    // This ensures Z only sends ACKs after receiving a message
                    setTimeout(finishFloodingPhase, 1500); // Wait 1.5s after message reception
                }
                
                function finishFloodingPhase() {
                        // Calculate discovery phase metrics
                        const discoveryTime = Date.now() - startTime;
                        
                        // Update metrics for discovery phase
                        updateMetrics({
                            deliveryTime: discoveryTime
                        });
                        
                        // Find the optimal path
                        const optimalPath = findOptimalPath();
                        
                        // Update caption to show ACK phase
                        document.getElementById('phase-caption').innerText = 
                            'MeshCore Path Discovery: Flooding complete. Sending ACK with optimal path information back to source.';
                        
                    // Add a flag to the window object to track if ACK has started
                    if (window.ackPhaseStarted) {
                        console.log("ACK phase already started, preventing duplicate start");
                        return;
                    }
                    
                    window.ackPhaseStarted = true;
                        
                        // Send ACK packets back along the optimal path from Z to A
                        if (optimalPath.length >= 2) {
                            // Create a slight delay before starting ACK process
                            setTimeout(function() {
                            startAckFloodFromDestination(optimalPath);
                            }, 1000);
                        } else {
                            // No valid path found
                            document.getElementById('phase-caption').innerText = 
                                'No valid path found between source and destination.';
                        }
                }
                
                // New function to properly handle the ACK flood back from destination to source
                function startAckFloodFromDestination(optimalPath) {
                    // Set up tracking for ACK phase
                    const hasNodeSentAck = new Set(['Z']); // Z has already sent ACK
                    const hasNodeReceivedAck = new Set(['Z']); // Z has already received ACK
                    const nodesInOptimalPath = new Set(optimalPath); // Track nodes in the optimal path
                    let activeAckAnimations = 0;
                    let ackReachedSource = false;
                    
                    // Create a nodeMap for easy lookup
                    const nodeMap = {};
                    nodes.forEach(node => {
                        nodeMap[node.id] = node;
                    });
                    
                    // The optimal path is from A to Z, so Z is the last element
                    // We need to get the node right before Z in the path
                    if (optimalPath.length >= 2) {
                        const zIndex = optimalPath.indexOf('Z');
                        if (zIndex > 0) { // Make sure Z isn't at the beginning (which would be weird)
                            const previousNode = optimalPath[zIndex - 1];
                            
                            console.log("Z is sending ACK to previous node:", previousNode);
                            
                            // ONLY send one ACK from Z to the previous node in the path
                            sendDirectedAck('Z', previousNode, 0);
                        }
                    }
                    
                    // New function to send a single directed ACK from one node to another
                    function sendDirectedAck(sourceId, targetId, depth) {
                        // Skip if target has already received ACK
                        if (hasNodeReceivedAck.has(targetId)) {
                            return;
                        }
                        
                        // Skip if source has not sent ACK yet (shouldn't happen, but a safeguard)
                        if (!hasNodeSentAck.has(sourceId)) {
                            hasNodeSentAck.add(sourceId);
                        }
                        
                        // Mark target as receiving ACK to prevent duplicates
                        hasNodeReceivedAck.add(targetId);
                        
                        // Update the source node's signal radius visualization to show it has sent an ACK
                        networkGroup.selectAll('.node-range')
                            .filter(d => d.id === sourceId)
                            .classed('has-broadcast', true)
                            .classed('has-sent-ack', true);
                        
                        // Create ACK packet with special styling
                        const packetData = createPacket(nodeMap[sourceId], nodeMap[targetId], 'packet-ack');
                        
                        // Increment active animations
                        activeAckAnimations++;
                        totalPackets++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        // Create visual effects - a ring and wave from the sender
                        if (sourceId.length === 1) { // Only for main nodes (A-Z) to reduce clutter
                            // Create purple wave for ACK (visual effect)
                            const ackWave = networkGroup.append('circle')
                                .attr('class', 'flood-wave ack-ring')
                            .attr('cx', nodeMap[sourceId].x)
                            .attr('cy', nodeMap[sourceId].y)
                                .attr('r', 10)
                                .attr('stroke', '#9c27b0')
                                .attr('stroke-opacity', 0.9)
                                .attr('stroke-width', 3)
                                .attr('stroke-dasharray', '5,5');
                            
                            // Animate the wave
                            ackWave.transition()
                                .duration(2000)
                                .attr('r', nodeMap[sourceId].range)
                                .attr('stroke-opacity', 0)
                                .remove();
                        }
                        
                        // Create special ring effect for ACK
                        const ackRing = networkGroup.append('circle')
                            .attr('class', 'packet-ring ack-ring')
                            .attr('cx', nodeMap[sourceId].x)
                            .attr('cy', nodeMap[sourceId].y)
                            .attr('r', 10)
                            .attr('stroke', '#9c27b0')
                            .attr('stroke-opacity', 0.8)
                            .attr('stroke-width', 2)
                            .attr('stroke-dasharray', '3,3')
                            .attr('fill', 'none');
                        
                        // Animate the ring
                        ackRing.transition()
                            .duration(500)
                            .attr('r', nodeMap[sourceId].range * 0.5)
                            .attr('stroke-opacity', 0)
                            .remove();
                        
                        // Animate the packet
                        animatePacket(packetData, nodeMap[sourceId], nodeMap[targetId], 600, 0, function() {
                            // Decrement active animations count
                            activeAckAnimations--;
                            
                            // If we reached the source A 
                            if (targetId === 'A' && !ackReachedSource) {
                                ackReachedSource = true;
                                
                                // Highlight the optimal path
                                highlightOptimalPath();
                                
                                // Update caption
                                document.getElementById('phase-caption').innerText = 
                                    'MeshCore Path Discovery: Route established! The source now knows the optimal path to the destination.';
                                
                                // Highlight source node to indicate route establishment
                                networkGroup.selectAll('.network-node')
                                    .filter(d => d.id === 'A')
                                    .transition()
                                    .duration(300)
                                    .attr('r', d => d.type === 'source' ? 20 : 14)
                                    .transition()
                                    .duration(300)
                                    .attr('r', d => d.type === 'source' ? 16 : 12);
                            }
                            
                            // Continue ACK along the path if this node hasn't sent an ACK yet
                            if (!hasNodeSentAck.has(targetId)) {
                                hasNodeSentAck.add(targetId);
                                
                                // Find the next node in the path (the one before this one)
                                const targetIndex = optimalPath.indexOf(targetId);
                                if (targetIndex > 0) {
                                    const nextNodeOnPath = optimalPath[targetIndex - 1];
                                    
                                    // Queue next node ACK
                                    setTimeout(() => {
                                        sendDirectedAck(targetId, nextNodeOnPath, depth + 1);
                                    }, 300);
                                }
                            }
                            });
                    }
                }
            }
            
            function animateMeshcoreDirectRouting() {
                // Reset visualization but keep optimal path highlighted
                resetVisualization(false);
                
                // Reset metrics but keep discovery metrics (if any)
                const discoveryTime = metrics.deliveryTime;
                const discoveryPackets = metrics.packetsSent;
                resetMetrics();
                updateMetrics({ 
                    packetsSent: discoveryPackets || 0,
                    deliveryTime: discoveryTime || 0
                });
                
                // Make sure optimal path is highlighted
                highlightOptimalPath();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'MeshCore Direct Routing: After discovery, radio signals follow only the established optimal path. Nodes not on the path drop signals.';
                
                // Find nodes by ID
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                // Start timing for direct routing phase
                const startTime = Date.now();
                let directPackets = 0;
                let hasReachedDestination = false;
                
                // Get optimal path for direct routing
                const optimalPath = findOptimalPath();
                
                // Create a set of nodes on the optimal path for quick lookup
                const nodesOnPath = new Set(optimalPath);
                
                // Animate direct route along optimal path
                if (optimalPath.length >= 2) {
                    // Show direct routing along optimal path
                    animateDirectPath(0);
                    
                    // After a delay, show dropped packets from nodes not on the path
                    setTimeout(showDroppedPackets, 3000);
                } else {
                    document.getElementById('phase-caption').innerText = 
                        'No valid path found between source and destination. Try refreshing to generate a new network.';
                }
                
                function animateDirectPath(currentIndex) {
                    if (currentIndex >= optimalPath.length - 1) {
                        // We've reached the destination
                        if (!hasReachedDestination) {
                            hasReachedDestination = true;
                            
                            // Calculate direct routing metrics
                            const directTime = Date.now() - startTime;
                            const totalTime = directTime + (discoveryTime || 0);
                            const hopsRequired = optimalPath.length - 1;
                            const totalPackets = (discoveryPackets || 0) + directPackets;
                            
                            // Calculate efficiency ratio (optimal path / total packets)
                            const efficiency = hopsRequired / totalPackets;
                            
                            // Update metrics
                            updateMetrics({
                                packetsSent: totalPackets,
                                deliveryTime: totalTime,
                                hopsRequired: hopsRequired,
                                efficiency: efficiency
                            });
                        }
                        
                        // Flash the destination node to show success
                        networkGroup.selectAll('.network-node')
                            .filter(d => d.id === 'Z')
                            .transition()
                            .duration(300)
                            .attr('r', d => d.type === 'destination' ? 20 : 14)
                            .attr('fill', '#4caf50')
                            .transition()
                            .duration(300)
                            .attr('r', d => d.type === 'destination' ? 16 : 12)
                            .attr('fill', '#e91e63');
                        
                        // After a delay, repeat the direct path demonstration
                        setTimeout(function() {
                            animateDirectPath(0);
                        }, 1500);
                        
                        return;
                    }
                    
                    // Create and animate packet along the current segment of the path
                    const sourceId = optimalPath[currentIndex];
                    const targetId = optimalPath[currentIndex + 1];
                    
                    // Create packet data instead of actual packet
                    const packetData = createPacket(nodeMap[sourceId], nodeMap[targetId], 'packet-meshcore');
                    
                    // Increment packet count
                    directPackets++;
                    updateMetrics({ packetsSent: (discoveryPackets || 0) + directPackets });
                    
                    animatePacket(packetData, nodeMap[sourceId], nodeMap[targetId], 500, 300, function() {
                        // Continue to the next segment
                        animateDirectPath(currentIndex + 1);
                    });
                }
                
                function showDroppedPackets() {
                    // Find a few nodes that are not on the optimal path but connected to nodes that are
                    const offPathConnections = [];
                    
                    // Set of nodes in the optimal path
                    const optimalPathNodeSet = new Set(optimalPath);
                    
                    // Look at each node in the optimal path
                    for (let i = 0; i < optimalPath.length; i++) {
                        const pathNodeId = optimalPath[i];
                        
                        // Find links where one end is this path node
                        const connectedLinks = links.filter(link => 
                            (link.source === pathNodeId || link.target === pathNodeId));
                        
                        // For each link, check if the other end is not in the optimal path
                        connectedLinks.forEach(link => {
                            const otherId = link.source === pathNodeId ? link.target : link.source;
                            
                            if (!optimalPathNodeSet.has(otherId)) {
                                offPathConnections.push({
                                    pathNodeId,
                                    offPathNodeId: otherId
                                });
                            }
                        });
                        
                        // Limit to 3 connections to avoid visual clutter
                        if (offPathConnections.length >= 3) break;
                    }
                    
                    // If we found any, animate dropped packets
                    if (offPathConnections.length > 0) {
                        // Update caption to explain dropped packets
                        document.getElementById('phase-caption').innerText = 
                            'MeshCore Direct Routing: Nodes not on the established route drop packets, ensuring bandwidth efficiency.';
                        
                        // Animate up to 3 dropped packets
                        const droppedCount = Math.min(offPathConnections.length, 3);
                        
                        for (let i = 0; i < droppedCount; i++) {
                            const connection = offPathConnections[i];
                            
                            // Create and animate a dropped packet
                            setTimeout(() => {
                                // Create packet data for dropped packet
                                const packetData = createPacket(
                                    nodeMap[connection.pathNodeId], 
                                    nodeMap[connection.offPathNodeId], 
                                    'packet-dropped'
                                );
                                
                                // Increment packet count
                                directPackets++;
                                updateMetrics({ packetsSent: (discoveryPackets || 0) + directPackets });
                                
                                // Show a partial animation that ends with a dropped packet effect
                                const sourceRing = networkGroup.append('circle')
                                    .attr('class', 'packet-ring dropped-ring')
                                    .attr('cx', nodeMap[connection.pathNodeId].x)
                                    .attr('cy', nodeMap[connection.pathNodeId].y)
                                    .attr('r', 10)
                                    .attr('stroke-opacity', 0.8)
                                    .attr('stroke-width', 2);
                                
                                // Animate the expanding ring partially
                                sourceRing.transition()
                                    .duration(400)
                                    .attr('r', nodeMap[connection.pathNodeId].range * 0.6)
                                    .attr('stroke-opacity', 0.4)
                                    .on('end', function() {
                                        // Show dropped packet effect at target node
                                        showDroppedMessageEffect(nodeMap[connection.offPathNodeId]);
                                        // Remove the ring
                                        sourceRing.remove();
                                });
                            }, i * 800); // Stagger the dropped packets
                        }
                    }
                }
            }
            
            function animateMeshtasticFlooding() {
                // Reset visualization
                resetVisualization();
                
                // Reset metrics
                resetMetrics();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'Meshtastic Flooding: Radio signals propagate through all nodes within range, which rebroadcast once per message to maximize delivery probability.';
                
                // Find nodes by ID
                const nodeMap = {};
                nodes.forEach(node => {
                    nodeMap[node.id] = node;
                });
                
                // Sets to track nodes at different stages:
                const pendingBroadcast = new Set(); // Nodes queued to broadcast
                const hasNodeBroadcast = new Set(['A']); // Nodes that have already broadcast (completed)
                const rebroadcastQueue = [];
                
                // Start timing for delivery time metric
                const startTime = Date.now();
                let hasReachedDestination = false;
                let totalPackets = 0;
                
                // Constants to control flooding visualization
                const MAX_CONCURRENT_ANIMATIONS = 25; // Limit number of concurrent animations
                const MAX_FLOOD_DEPTH = 7; // Meshtastic is limited to 7 hops
                let activeAnimations = 0;
                
                // Start flood from node A with visible waves
                floodFromNode('A', 0);
                
                function floodFromNode(nodeId, depth) {
                    if (depth > MAX_FLOOD_DEPTH) return; // Limit recursion depth
                    
                    const sourceNode = nodes.find(n => n.id === nodeId);
                    
                    // Create a visible flood wave from this node if it's a key node
                    // Only show waves for original nodes (A-Z) to reduce visual clutter
                    if (nodeId.length === 1) {
                        createFloodWave(sourceNode, 'meshtastic-wave');
                    }
                    
                    // Mark this node as having broadcast - this is crucial for preventing duplicate broadcasts
                    hasNodeBroadcast.add(nodeId);
                    // Remove from pending if it was there
                    pendingBroadcast.delete(nodeId);
                    
                    // Update the node's signal radius visualization to show it has broadcast
                    networkGroup.selectAll('.node-range')
                        .filter(d => d.id === nodeId)
                        .classed('has-broadcast', true);
                    
                    // Get all connections for this node that are in range
                    const nodeLinks = links.filter(link => 
                        (link.source === nodeId || link.target === nodeId));
                    
                    // Process all node connections, queue if too many for animation
                    nodeLinks.forEach((link, index) => {
                        const targetId = link.source === nodeId ? link.target : link.source;
                        
                        // Skip if target has already broadcast OR is pending broadcast
                        if (hasNodeBroadcast.has(targetId) || pendingBroadcast.has(targetId)) {
                            setTimeout(() => {
                                showDroppedMessageEffect(nodeMap[targetId]);
                            }, 200 + (Math.min(index, 10) * 50)); // Stagger dropped effects but cap to avoid long delays
                            return;
                        }
                        
                        // Mark this node as pending broadcast to prevent duplicates
                        pendingBroadcast.add(targetId);
                        
                        // Check if we're already at the animation limit
                        if (activeAnimations >= MAX_CONCURRENT_ANIMATIONS) {
                            // Queue this broadcast
                                rebroadcastQueue.push({
                                    sourceId: nodeId,
                                    targetId: targetId,
                                    depth: depth,
                                    delay: 300
                                });
                            return;
                        }
                        
                        // Create packet data instead of actual packet element
                        const packetData = createPacket(nodeMap[nodeId], nodeMap[targetId], 'packet-meshtastic');
                        
                        // Increment packet count and active animations
                        totalPackets++;
                        activeAnimations++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        // Stagger animation start times, but cap to avoid long delays
                        const staggerDelay = Math.min(index, 10) * 50;
                        
                        animatePacket(packetData, nodeMap[nodeId], nodeMap[targetId], 800, 200 + staggerDelay, function() {
                            // Decrement active animations count
                            activeAnimations--;
                            
                            // Schedule the next wave - node will broadcast if not already in hasNodeBroadcast
                            if (!hasNodeBroadcast.has(targetId)) {
                                rebroadcastQueue.push({
                                    sourceId: targetId,
                                    targetId: null, // No specific target for flooding
                                    depth: depth + 1,
                                    delay: 500
                                });
                            } else {
                                // Already broadcast, remove from pending if needed
                                pendingBroadcast.delete(targetId);
                            }
                            
                            // Process the queue immediately if we're below the animation limit
                            if (activeAnimations < MAX_CONCURRENT_ANIMATIONS / 2) {
                                processRebroadcastQueue();
                            }
                            
                            // If we reached Z, show success effect and update metrics
                            if (targetId === 'Z' && !hasReachedDestination) {
                                hasReachedDestination = true;
                                
                                // Calculate delivery time
                                const deliveryTime = Date.now() - startTime;
                                
                                // Calculate hop count (by depth)
                                const hopsRequired = depth + 1;
                                
                                // Calculate efficiency (optimal path / total packets)
                                // A lower ratio means more network congestion
                                const optimalPath = findOptimalPath();
                                const efficiency = optimalPath.length > 0 ? 
                                    (optimalPath.length - 1) / totalPackets : 0;
                                
                                // Update metrics
                                updateMetrics({
                                    deliveryTime: deliveryTime,
                                    hopsRequired: hopsRequired,
                                    efficiency: efficiency
                                });
                                
                                // Flash the destination node
                                networkGroup.selectAll('.network-node')
                                    .filter(d => d.id === 'Z')
                                    .transition()
                                    .duration(300)
                                    .attr('r', d => d.type === 'destination' ? 20 : 14)
                                    .attr('fill', '#4caf50')
                                    .transition()
                                    .duration(300)
                                    .attr('r', d => d.type === 'destination' ? 16 : 12)
                                    .attr('fill', '#4caf50'); // Keep green permanently
                                
                                // Update caption to indicate message arrived but flooding continues
                                document.getElementById('phase-caption').innerText = 
                                    'Meshtastic Flooding: Message reached destination, but flooding continues up to 7 hops.';
                            }
                        });
                    });
                    
                    // Process queue after a delay if no animations were started
                    if (activeAnimations === 0) {
                        setTimeout(processRebroadcastQueue, 500);
                    }
                }
                
                function processRebroadcastQueue() {
                    // Process up to the max concurrent animations limit
                    let processed = 0;
                    
                    // Increase batch size to process queue faster
                    const batchSize = Math.min(MAX_CONCURRENT_ANIMATIONS, 10);
                    
                    while (rebroadcastQueue.length > 0 && activeAnimations < MAX_CONCURRENT_ANIMATIONS && processed < batchSize) {
                        const nextBroadcast = rebroadcastQueue.shift();
                        processed++;
                        
                        if (nextBroadcast.targetId === null) {
                            // This is a flooding request
                            
                            // FIXED: A node should rebroadcast if it's in pendingBroadcast and not in hasNodeBroadcast
                            // Only skip if node has already broadcast
                            if (!hasNodeBroadcast.has(nextBroadcast.sourceId)) {
                                setTimeout(function() {
                                    floodFromNode(nextBroadcast.sourceId, nextBroadcast.depth);
                                }, nextBroadcast.delay);
                            } else {
                                // Already broadcast, remove from pending if needed
                                pendingBroadcast.delete(nextBroadcast.sourceId);
                            }
                        } else {
                            // This is a directed packet
                            
                            // Skip if target has already broadcast or is pending
                            if (hasNodeBroadcast.has(nextBroadcast.targetId) || pendingBroadcast.has(nextBroadcast.targetId)) {
                                // Show dropped message effect
                                setTimeout(() => {
                                    showDroppedMessageEffect(nodeMap[nextBroadcast.targetId]);
                                }, 200);
                                continue;
                            }
                            
                            // Mark as pending to prevent duplicates
                            pendingBroadcast.add(nextBroadcast.targetId);
                            
                            // Create packet data
                            const packetData = createPacket(nodeMap[nextBroadcast.sourceId], nodeMap[nextBroadcast.targetId], 'packet-meshtastic');
                            
                            // Increment packet count and active animations
                            totalPackets++;
                            activeAnimations++;
                            updateMetrics({ packetsSent: totalPackets });
                            
                            animatePacket(packetData, nodeMap[nextBroadcast.sourceId], nodeMap[nextBroadcast.targetId], 800, 0, function() {
                                // Decrement active animations count
                                activeAnimations--;
                                
                                // Schedule the next wave only if node hasn't broadcast yet
                                if (!hasNodeBroadcast.has(nextBroadcast.targetId)) {
                                    rebroadcastQueue.push({
                                        sourceId: nextBroadcast.targetId,
                                        targetId: null,
                                        depth: nextBroadcast.depth + 1,
                                        delay: 300
                                    });
                                } else {
                                    // Already broadcast, remove from pending
                                    pendingBroadcast.delete(nextBroadcast.targetId);
                                }
                                
                                // If we reached Z, update metrics
                                if (nextBroadcast.targetId === 'Z' && !hasReachedDestination) {
                                    hasReachedDestination = true;
                                    
                                    // Calculate metrics
                                    const deliveryTime = Date.now() - startTime;
                                    const hopsRequired = nextBroadcast.depth + 1;
                                    const optimalPath = findOptimalPath();
                                    const efficiency = optimalPath.length > 0 ? 
                                        (optimalPath.length - 1) / totalPackets : 0;
                                    
                                    updateMetrics({
                                        deliveryTime: deliveryTime,
                                        hopsRequired: hopsRequired,
                                        efficiency: efficiency
                                    });
                                    
                                    // Flash the destination node and keep it green
                                    networkGroup.selectAll('.network-node')
                                        .filter(d => d.id === 'Z')
                                        .transition()
                                        .duration(300)
                                        .attr('r', d => d.type === 'destination' ? 20 : 14)
                                        .attr('fill', '#4caf50')
                                        .transition()
                                        .duration(300)
                                        .attr('r', d => d.type === 'destination' ? 16 : 12)
                                        .attr('fill', '#4caf50'); // Keep green permanently
                                    
                                    // Update caption
                                    document.getElementById('phase-caption').innerText = 
                                        'Meshtastic Flooding: Message reached destination, but flooding continues up to 7 hops.';
                                }
                                
                                // Process more from the queue
                                if (rebroadcastQueue.length > 0) {
                                    processRebroadcastQueue();
                                }
                            });
                        }
                    }
                    
                    // If there are still items in the queue, schedule another processing round with shorter delay
                    if (rebroadcastQueue.length > 0) {
                        setTimeout(processRebroadcastQueue, 400); // Faster processing of queue
                    }
                }
            }
            
            function resetVisualization(clearOptimalPath = true) {
                // Reset the ACK started flag
                window.ackPhaseStarted = false;
                
                // Remove all rings and waves
                networkGroup.selectAll('.packet-ring, .flood-wave').remove();
                
                // Clear any existing animations
                networkGroup.selectAll('.network-node').interrupt();
                
                // Reset node range visualization classes
                networkGroup.selectAll('.node-range')
                    .classed('has-broadcast', false)
                    .classed('has-sent-ack', false)
                    .classed('has-received-message', false)
                    .classed('has-received-ack', false);
                
                // Reset node colors and message-received class
                networkGroup.selectAll('.network-node')
                    .classed('message-received', false)
                    .transition()
                    .duration(300)
                    .attr('fill', d => {
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        if (d.id === 'E' || d.name.includes('Hub')) return '#ff9800';
                        return '#ddd';
                    })
                    .attr('r', d => {
                        // Make source and destination nodes larger
                        if (d.type === 'source' || d.type === 'destination') return 16;
                        // Make hub nodes slightly larger
                        if (d.id === 'E' || d.name.includes('Hub')) return 14;
                        // Make original nodes (B-H) slightly larger
                        if (d.id.length === 1) return 12;
                        // Make all other nodes smaller
                        return 8;
                    });
                
                // Clear optimal path highlighting if requested
                if (clearOptimalPath) {
                    // Remove highlight classes since we no longer have static links
                    networkGroup.selectAll('.highlighted-path').classed('highlighted-path', false);
                    // Remove any path highlight lines
                    networkGroup.selectAll('.path-highlight-line').remove();
                }
            }
            
            function animateComparison() {
                // Reset visualization
                resetVisualization();
                
                // Update caption
                document.getElementById('phase-caption').innerText = 
                    'Side-by-Side Comparison: Meshtastic flooding (left) vs MeshCore selective routing (right)';
                
                // Split the visualization into two parts
                const splitWidth = width / 2;
                
                // Create comparison container
                const comparisonContainer = d3.select('#network-visualization')
                    .append('div')
                    .attr('class', 'comparison-container')
                    .style('display', 'flex')
                    .style('width', '100%')
                    .style('height', '100%');
                
                // Create left view (Meshtastic)
                const leftView = comparisonContainer
                    .append('div')
                    .attr('class', 'comparison-view left-view')
                    .style('width', '50%')
                    .style('height', '100%')
                    .style('position', 'relative')
                    .style('border-right', '1px dashed #ccc');
                
                // Create right view (MeshCore)
                const rightView = comparisonContainer
                    .append('div')
                    .attr('class', 'comparison-view right-view')
                    .style('width', '50%')
                    .style('height', '100%')
                    .style('position', 'relative');
                
                // Create SVG for left view
                const leftSvg = leftView
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%');
                
                // Create SVG for right view
                const rightSvg = rightView
                    .append('svg')
                    .attr('width', '100%')
                    .attr('height', '100%');
                
                // Add labels
                leftView.append('div')
                    .attr('class', 'view-label')
                    .style('position', 'absolute')
                    .style('top', '10px')
                    .style('left', '10px')
                    .style('background-color', 'rgba(30, 136, 229, 0.9)')
                    .style('color', 'white')
                    .style('padding', '5px 10px')
                    .style('border-radius', '4px')
                    .style('font-weight', 'bold')
                    .text('Meshtastic Flooding');
                
                rightView.append('div')
                    .attr('class', 'view-label')
                    .style('position', 'absolute')
                    .style('top', '10px')
                    .style('left', '10px')
                    .style('background-color', 'rgba(67, 160, 71, 0.9)')
                    .style('color', 'white')
                    .style('padding', '5px 10px')
                    .style('border-radius', '4px')
                    .style('font-weight', 'bold')
                    .text('MeshCore Selective Routing');
                
                // Add metrics displays
                const leftMetrics = leftView.append('div')
                    .attr('class', 'view-metrics')
                    .style('position', 'absolute')
                    .style('bottom', '10px')
                    .style('left', '10px')
                    .style('right', '10px')
                    .style('background-color', 'rgba(255, 255, 255, 0.9)')
                    .style('padding', '5px')
                    .style('border-radius', '4px')
                    .style('font-size', '0.9em');
                
                const rightMetrics = rightView.append('div')
                    .attr('class', 'view-metrics')
                    .style('position', 'absolute')
                    .style('bottom', '10px')
                    .style('left', '10px')
                    .style('right', '10px')
                    .style('background-color', 'rgba(255, 255, 255, 0.9)')
                    .style('padding', '5px')
                    .style('border-radius', '4px')
                    .style('font-size', '0.9em');
                
                leftMetrics.html('<b>Packets:</b> <span id="left-packets">0</span> | <b>Efficiency:</b> <span id="left-efficiency">0%</span> | <b>Time:</b> <span id="left-time">0ms</span>');
                rightMetrics.html('<b>Packets:</b> <span id="right-packets">0</span> | <b>Efficiency:</b> <span id="right-efficiency">0%</span> | <b>Time:</b> <span id="right-time">0ms</span>');
                
                // Hide main SVG
                svg.style('display', 'none');
                
                // Add start button
                const startButton = d3.select('#network-visualization')
                    .append('button')
                    .attr('class', 'start-comparison-button')
                    .style('position', 'absolute')
                    .style('top', '50%')
                    .style('left', '50%')
                    .style('transform', 'translate(-50%, -50%)')
                    .style('z-index', '100')
                    .style('padding', '10px 20px')
                    .style('background-color', '#e74c3c')
                    .style('color', 'white')
                    .style('border', 'none')
                    .style('border-radius', '5px')
                    .style('font-weight', 'bold')
                    .style('cursor', 'pointer')
                    .text('Start Comparison');
                
                // Add exit button
                const exitButton = d3.select('#network-visualization')
                    .append('button')
                    .attr('class', 'exit-comparison-button')
                    .style('position', 'absolute')
                    .style('top', '10px')
                    .style('right', '10px')
                    .style('z-index', '100')
                    .style('padding', '5px 10px')
                    .style('background-color', '#6c757d')
                    .style('color', 'white')
                    .style('border', 'none')
                    .style('border-radius', '5px')
                    .style('font-weight', 'bold')
                    .style('cursor', 'pointer')
                    .text('Exit Comparison')
                    .on('click', exitComparisonView);
                
                startButton.on('click', function() {
                    // Hide the button
                    d3.select(this).style('display', 'none');
                    
                    // Run animations simultaneously
                    setTimeout(() => {
                        // This is a simplified version showing the concept
                        alert('For a full comparison, please run the individual animations. The side-by-side comparison requires significant refactoring of the visualization code.');
                        
                        // For a proper implementation, you would need to:
                        // 1. Clone the network generation code to create two separate networks
                        // 2. Refactor the animation functions to take an SVG container as parameter
                        // 3. Run the animations in parallel on both networks
                    }, 100);
                });
            }
            
            function exitComparisonView() {
                // Remove comparison elements
                d3.select('.comparison-container').remove();
                d3.select('.start-comparison-button').remove();
                d3.select('.exit-comparison-button').remove();
                
                // Show main SVG again
                svg.style('display', 'block');
                
                // Reset the visualization
                resetVisualization();
                
                // Reset active button state
                document.querySelectorAll('.control-button').forEach(btn => {
                    btn.classList.remove('active');
                });
                document.getElementById('btn-meshtastic').classList.add('active');
                
                // Reset caption
                document.getElementById('phase-caption').innerText = 
                    'Select a routing method to visualize different approaches to mesh networking.';
                
                // Reset metrics
                resetMetrics();
            }
            
            // Start with Meshtastic flooding by default
            setTimeout(animateMeshtasticFlooding, 500);
            
            // Add this function after createFloodWave and before animateMeshtasticFlooding
            function showDroppedMessageEffect(node) {
                // Check if we got a valid node
                if (!node) return;
                
                // Create a red flash effect
                const flash = networkGroup.append('circle')
                    .attr('class', 'packet-dropped-flash')
                    .attr('cx', node.x)
                    .attr('cy', node.y)
                    .attr('r', 10)
                    .attr('fill', '#dc3545')
                    .attr('fill-opacity', 0.6)
                    .attr('stroke', '#dc3545')
                    .attr('stroke-width', 2)
                    .attr('stroke-opacity', 0.8);
                
                // Animate the flash
                flash.transition()
                    .duration(200)
                    .attr('r', 20)
                    .attr('fill-opacity', 0.7)
                    .transition()
                    .duration(200)
                    .attr('r', 5)
                    .attr('fill-opacity', 0)
                    .remove();
                
                // Check if this node has received a message before
                const hasReceivedMessage = networkGroup.selectAll('.network-node')
                    .filter(d => d.id === node.id)
                    .classed('message-received');
                
                // Change node color to RED to indicate dropped message, but return to green if it previously received a message
                networkGroup.selectAll('.network-node')
                    .filter(d => d.id === node.id)
                    .transition()
                    .duration(200)
                    .attr('fill', '#dc3545')
                    .transition()
                    .duration(800) // Keep red for a short time
                    .attr('fill', d => {
                        // If node already received a message, return to green
                        if (hasReceivedMessage) return '#4caf50';
                        // Otherwise return to original color
                        if (d.type === 'source') return '#4caf50';
                        if (d.type === 'destination') return '#e91e63';
                        if (d.id === 'E' || d.name.includes('Hub')) return '#ff9800';
                        return '#ddd';
                    });
            }

            function processAckQueue() {
                // Process up to the max concurrent animations limit
                let processed = 0;
                const batchSize = Math.min(MAX_CONCURRENT_ANIMATIONS, 10);
                
                while (ackQueue.length > 0 && activeAckAnimations < MAX_CONCURRENT_ANIMATIONS && processed < batchSize) {
                    const nextBroadcast = ackQueue.shift();
                    processed++;
                    
                    if (nextBroadcast.targetId === null) {
                        // This is a flooding request
                        
                        // Only process if node hasn't sent ACK yet
                        if (!hasNodeSentAck.has(nextBroadcast.sourceId)) {
                            setTimeout(function() {
                                floodAckFromNode(nextBroadcast.sourceId, nextBroadcast.depth);
                            }, nextBroadcast.delay);
                        }
                    } else {
                        // This is a directed packet
                        
                        // Skip if target has already received ACK
                        if (hasNodeReceivedAck.has(nextBroadcast.targetId)) {
                            // Show dropped message effect
                            setTimeout(() => {
                                showDroppedMessageEffect(nodeMap[nextBroadcast.targetId]);
                            }, 200);
                            continue;
                        }
                        
                        // Determine if this node is on the optimal path
                        const isOptimalPathNode = nodesInOptimalPath.has(nextBroadcast.targetId);
                        
                        // Create ACK packet
                        const packetData = createPacket(nodeMap[nextBroadcast.sourceId], nodeMap[nextBroadcast.targetId], 'packet-ack');
                        
                        // Mark the target as having received an ACK
                        hasNodeReceivedAck.add(nextBroadcast.targetId);
                        
                        // Increment counters
                        activeAckAnimations++;
                        totalPackets++;
                        updateMetrics({ packetsSent: totalPackets });
                        
                        // Special ring for ACK
                        const ackRing = networkGroup.append('circle')
                            .attr('class', 'packet-ring ack-ring')
                            .attr('cx', nodeMap[nextBroadcast.sourceId].x)
                            .attr('cy', nodeMap[nextBroadcast.sourceId].y)
                            .attr('r', 10)
                            .attr('stroke', '#9c27b0')
                            .attr('stroke-opacity', 0.8)
                            .attr('stroke-width', 2)
                            .attr('stroke-dasharray', '3,3')
                            .attr('fill', 'none');
                        
                        // Animate the ring
                        ackRing.transition()
                            .duration(500)
                            .attr('r', nodeMap[nextBroadcast.sourceId].range * 0.5)
                            .attr('stroke-opacity', 0)
                            .remove();
                        
                        animatePacket(packetData, nodeMap[nextBroadcast.sourceId], nodeMap[nextBroadcast.targetId], 600, 0, function() {
                            // Decrement active animations count
                            activeAckAnimations--;
                            
                            // If we reached the source A and it's on the optimal path
                            if (nextBroadcast.targetId === 'A' && !ackReachedSource && isOptimalPathNode) {
                                ackReachedSource = true;
                                
                                // Only now highlight the optimal path
                                highlightOptimalPath();
                                
                                // Update caption
                                document.getElementById('phase-caption').innerText = 
                                    'MeshCore Path Discovery: Route established! The source now knows the optimal path to the destination.';
                                
                                // Highlight source node to indicate route establishment
                                networkGroup.selectAll('.network-node')
                                    .filter(d => d.id === 'A')
                                    .transition()
                                    .duration(300)
                                    .attr('r', d => d.type === 'source' ? 20 : 14)
                                    .transition()
                                    .duration(300)
                                    .attr('r', d => d.type === 'source' ? 16 : 12);
                            }
                            
                            // Only continue flooding if this node is on the optimal path AND hasn't sent ACK yet
                            if (isOptimalPathNode && !hasNodeSentAck.has(nextBroadcast.targetId)) {
                                // Queue this node to send ACKs
                                ackQueue.push({
                                    sourceId: nextBroadcast.targetId,
                                    targetId: null,
                                    depth: nextBroadcast.depth + 1,
                                    delay: 300
                                });
                            }
                            
                            // Process more from the queue
                            if (ackQueue.length > 0 && activeAckAnimations < MAX_CONCURRENT_ANIMATIONS / 2) {
                                processAckQueue();
                            }
                        });
                    }
                }
                
                // If there are still items in the queue, schedule another processing round
                if (ackQueue.length > 0) {
                    setTimeout(processAckQueue, 400);
                }
            }
        });
        
        // Add smooth scrolling and other UI functionality
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function(e) {
                e.preventDefault();
                
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    window.scrollTo({
                        top: target.offsetTop - 70,
                        behavior: 'smooth'
                    });
                }
            });
        });
    </script>
</body>
</html> 